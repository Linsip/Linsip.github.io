{"meta":{"title":"Linsip","subtitle":"","description":"","author":"Linsip","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-04-28T15:59:57.000Z","updated":"2021-05-11T16:10:57.224Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-11T12:34:16.000Z","updated":"2021-05-11T12:37:51.841Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-11T15:59:37.000Z","updated":"2021-05-11T15:59:37.000Z","comments":false,"path":"js/aplayer.js","permalink":"http://example.com/js/aplayer.js","excerpt":"","text":"!(function() { var oldLoadAp = window.onload; window.onload = function () { oldLoadAp && oldLoadAp(); new APlayer({ container: document.getElementById('aplayer'), fixed: true, autoplay: false, loop: 'all', order: 'random', //theme: '#b7daff', preload: 'auto', listFolded: true, listMaxHeight: 90, lrcType: 3, audio: [ { name: '彼女は旅に出る - 鎖那', artist: 'Hush a by little girl', url: '/songs/彼女は旅に出る - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/彼女は旅に出る - 鎖那.lrc' }, { name: '鍵っ子 - 鎖那', artist: 'Hush a by little girl', url: '/songs/鍵っ子 - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/鍵っ子 - 鎖那.lrc' }, { name: 'シュテルン - 鎖那', artist: 'Hush a by little girl', url: '/songs/シュテルン - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/シュテルン - 鎖那.lrc' }, { name: 'オオカミと少女 - 鎖那', artist: 'Hush a by little girl', url: '/songs/オオカミと少女 - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/オオカミと少女 - 鎖那.lrc' } ] }); } })();"},{"title":"","date":"2021-05-01T05:55:57.927Z","updated":"2021-05-01T05:55:57.927Z","comments":false,"path":"js/daovoice.js","permalink":"http://example.com/js/daovoice.js","excerpt":"","text":"!(function() { var appId = '0d1240ec'; (function (i, s, o, g, r, a, m) { i['DaoVoiceObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments); }; i[r].l = 1 * new Date(); a = s.createElement(o); m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; a.charset = 'utf-8'; m.parentNode.insertBefore(a, m); })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + '//widget.daovoice.io/widget/' + appId + '.js', 'daovoice'); daovoice('init', { app_id: appId, }); daovoice('update'); })();"}],"posts":[{"title":"Gitee+PicGo免费私人图床搭建教程","slug":"Gitee-PicGo免费私人图床搭建教程","date":"2021-05-11T12:18:26.000Z","updated":"2021-05-11T13:03:34.295Z","comments":true,"path":"2021/05/11/Gitee-PicGo免费私人图床搭建教程/","link":"","permalink":"http://example.com/2021/05/11/Gitee-PicGo%E5%85%8D%E8%B4%B9%E7%A7%81%E4%BA%BA%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"在写博客的时候经常遇到需要传图","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"OOP原则","slug":"OOP原则","date":"2021-05-11T07:33:58.000Z","updated":"2021-05-11T13:06:23.947Z","comments":true,"path":"2021/05/11/OOP原则/","link":"","permalink":"http://example.com/2021/05/11/OOP%E5%8E%9F%E5%88%99/","excerpt":"","text":"OOP原则OOP概述 面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。 什么是优秀的代码？ 代码可读性高 逻辑清晰 高内聚，低耦合 ··· OOP三大特性 封装 继承 多态 OOP五大设计原则单一职责原则 开闭原则 里氏替换原则 接口隔离原则 依赖倒置原则 总结高内聚，低耦合","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"GUI图形用户界面","slug":"GUI","date":"2021-05-06T14:21:24.000Z","updated":"2021-05-11T12:05:49.121Z","comments":true,"path":"2021/05/06/GUI/","link":"","permalink":"http://example.com/2021/05/06/GUI/","excerpt":"","text":"GUIGUI全称Graphical User Interface，图形用户界面 组件 窗口 弹窗 面板 文本框 列表框 按钮 图片 监听事件 鼠标 键盘事件 简介GUI核心技术：AWT、SWing 为什么不火 界面不美观 需要jre环境 为什么要学习GUI MVC，了解监听器 可以写出自己心中想要的工具 工作中可能维护到SWing界面 AWTAWT介绍AWT(Abstract Windows Toolkit)抽象窗口工具 包含很多类和接口 元素：窗口、按钮、文本框 Java.awt包的层次结构如下 组件和容器Component and Container容器 容器(Container)也是一个类，实际上是Component的子类，因此容器本身也是一个组件，具有组件的所有性质，但是它的主要功能是容纳其它组件和容器。容器可以简化图形化界面的设计，以整体结构来布置界面。所有的容器都可以通过add()方法向容器中添加组件。常用的容器3种：Panel, Frame, Applet。 来源：百度百科 框架Frame 构造方法： 1Frame frame = new Frame(&quot;&quot;); 要生成一个窗口，通常使用Window的子类Frame类进行实例化，而不是直接使用Window 类，框架的外观就像平常Windows系统下的窗口，有标题、边框、菜单和大小等。setSize()方法可以设置框架尺寸的大小，setVisibe()方法可以设置窗口的可见性。 来源：百度百科 示例： 12345678910111213141516171819202122package cn.linsip.lesson01;import java.awt.*;//第一个图形界面public class TestFrame &#123; public static void main(String[] args) &#123; //Frame 看源码 Frame frame = new Frame(&quot;我的第一个Java图形界面&quot;); //设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400, 400); //设置背景颜色 frame.setBackground(new Color(1, 1, 1)); //设置弹出的初始位置 frame.setLocation(0, 0); //设置大小固定 frame.setResizable(false); &#125;&#125; 窗口出现问题 窗口关闭不掉 解决方法：停止Java程序运行 回顾封装： 1234567891011121314151617181920212223242526272829package cn.linsip.lesson01;import java.awt.*;//封装TestFramepublic class TestFrame02 &#123; public static void main(String[] args) &#123; //开启多个窗口 MyFrame myFrame1 = new MyFrame(200, 200, 200, 200); MyFrame myFrame2 = new MyFrame(400, 200, 200, 200); MyFrame myFrame3 = new MyFrame(200, 400, 200, 200); MyFrame myFrame4 = new MyFrame(400, 400, 200, 200); &#125;&#125;//自定义类来继承Frame实现封装class MyFrame extends Frame &#123; //定义静态变量，用于区别多个窗口 static int id; public MyFrame(int x, int y, int w, int h) &#123; //调用父类即Frame super(&quot;MyFrame&quot; + (++id)); //设置参数 setVisible(true); setBackground(Color.black); setBounds(x, y, w, h); setResizable(false); &#125;&#125; 面板panel 框架一般用作Java应用程序的窗口，而Applet是Java小程序的窗口。与Frame不同，Applet是在网页中显示的，也可以通过添加Panel进行组件布局。 来源：百度百科 Panel一个空间，非独立存在 可以在panel中添加文本框、文本域、列表、单选按钮、复选按钮、画布、标签、字体大小、事件、滚动条 构造方法 1Panel panel = new Panel(); 示例 12345678910111213141516171819202122232425262728293031package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;//Panelpublic class TestPanel &#123; public static void main(String[] args) &#123; Frame frame = new MyFrame(100, 100, 400, 400, Color.RED); Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 panel.setBounds(100, 100, 200, 200);//Panel的坐标是相对于Frame的 panel.setBackground(Color.white); //panel加入frame frame.add(panel); //窗口监听WindowListener，实现关闭窗口功能,监听器参数是一个内部类WindowAdapter //适配器模式 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 布局管理器 布局管理器（LayoutManager）：每个容器都有一个布局管理器，当容器需要对某个组件进行定位或判断其大小、尺寸时，就会调用其对应的布局管理器。使用布局管理器可以实现跨平台的特性，并且获得动态的布局效果。布局管理器负责管理组件的排列顺序、大小和位置。不同的布局管理器使用不同的布局策略，容器可以通过选择不同的布局管理器来决定如何布局。 来源：百度百科 流式布局Flowlayout FlowLayout是Panel 和 Applet 的默认布局管理器。在该布局管理器中，组件在容器中按照从上到下，从左到右的顺序进行排列，行满后则换行。 构造方法 123456//默认构造方法，设置居中对齐方式，横向和纵向间隔均为默认5像素FlowLayout();//设置居左对齐，横向和纵向间隔均为默认5像素FlowLayout(new FlowLayout.LEFT);//设置居右对齐，横向间隔20像素，纵向间隔20像FlowLayout(new FlowLayout.RIGHT, 20, 20); 示例 12345678910111213141516171819202122package cn.linsip.lesson01;import java.awt.*;public class TestFlowLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); //组件按钮 Button button1 = new Button(&quot;button1&quot;); Button button2 = new Button(&quot;button2&quot;); Button button3 = new Button(&quot;button3&quot;); //设置流式布局 frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setVisible(true); frame.setBounds(100,100,200,200); //添加Buttun到Frame frame.add(button1); frame.add(button2); frame.add(button3); &#125;&#125; 边界布局管理器BorderLayout BorderLayout是Window、Frame和Dialog的默认布局管理器，其将容器分成North、South、East、West和Center 5个区域，每个区域只能放置一个组件。在使用add()方法添加组件到容器时，必须指定将其放置在哪个区域中。使用BorderLayout时，如果容器大小发生变换，组件的相对位置不变。 来源：百度百科 构造方法 1BorderLayout bl = new BorderLayout(); 示例 12345678910111213141516171819202122232425262728package cn.linsip.lesson01;import java.awt.*;public class TestBorderTest &#123; public static void main(String[] args) &#123; //一个Frame Frame frame = new Frame(); //四个按钮 Button east = new Button(&quot;EAST&quot;); Button west = new Button(&quot;WEST&quot;); Button south = new Button(&quot;SOUTH&quot;); Button north = new Button(&quot;NORTH&quot;); Button center = new Button(&quot;CENTER&quot;); //按钮添加到frame frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); //设置frame属性 frame.setVisible(true); frame.setBounds(100,100,200,200); &#125;&#125; 网格布局管理器GridLayout GridLayout 可使容器中的各个组件呈网格状布局，平局占据容器的空间，即使容器的大小发生变化，每个组件还是平均占据容器的空间。和FlowLayout一样，GridLayout也是按照从上到下，从左到右的规律进行排列的。 来源：百度百科 构造方法 1GridLayout = new GridLayout(); 示例 12345678910111213141516171819202122232425262728293031323334package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestGridLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setVisible(true); Button button1 = new Button(&quot;butten1&quot;); Button button2 = new Button(&quot;button2&quot;); Button button3 = new Button(&quot;button3&quot;); Button button4 = new Button(&quot;button4&quot;); Button button5 = new Button(&quot;button5&quot;); Button button6 = new Button(&quot;button6&quot;); frame.setLayout(new GridLayout(3,2)); //frame.setBounds(100,100,200,200); frame.add(button1); frame.add(button2); frame.add(button3); frame.add(button4); frame.add(button5); frame.add(button6); frame.pack();//Java函数，自动匹配大小 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 练习 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class FrameDemo &#123; public static void main(String[] args) &#123; Frame frame = new Frame(&quot;练习&quot;); Panel panel1 = new Panel(new BorderLayout()); Panel panel2 = new Panel(new GridLayout(2, 1)); Panel panel3 = new Panel(new BorderLayout()); Panel panel4 = new Panel(new GridLayout(2, 2)); frame.setLayout(new GridLayout(2, 1)); frame.setSize(400, 400); frame.setVisible(true); panel1.add(new Button(&quot;east&quot;), BorderLayout.EAST); panel1.add(new Button(&quot;west&quot;), BorderLayout.WEST); panel2.add(new Button(&quot;p2-1&quot;)); panel2.add(new Button(&quot;p2-2&quot;)); panel1.add(panel2, BorderLayout.CENTER); frame.add(panel1); panel3.add(new Button(&quot;east&quot;), BorderLayout.EAST); panel3.add(new Button(&quot;west&quot;), BorderLayout.WEST); panel4.add(new Button(&quot;p4-1&quot;)); panel4.add(new Button(&quot;p4-2&quot;)); panel4.add(new Button(&quot;p4-3&quot;)); panel4.add(new Button(&quot;p4-4&quot;)); panel3.add(panel4, BorderLayout.CENTER); frame.add(panel3); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 总结： Frame是一个顶级窗口 Panel无法单独显示，必须添加其到某个容器中 掌握3种布局管理器 Frame设置大小、定位、背景颜色、可见性、监听。 事件监听 Java事件监听器是由事件类和监听接口组成，自定义一个事件前，必须提供一个事件的监听接口以及一个事件类。JAVA中监听接口是继承java.util.EventListener的类，事件类继承java.util.EventObject的类。 来源：百度百科 事件发生的时候，该干什么 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestActionEvent01 &#123; public static void main(String[] args) &#123; //按下按钮，触发事件 Frame frame = new Frame(); Button button = new Button(&quot;say hello&quot;); //给按钮添加一个事件监听，ActionListener是一个接口，需要一个ActionListener参数，我们自定义一个类来实现这个接口 MyActionListener myActionListener = new MyActionListener(); //按钮添加监听 button.addActionListener(myActionListener); //按钮加入frame frame.add(button, BorderLayout.CENTER); //设置窗口属性 frame.pack(); frame.setVisible(true); //我们这里重写以下关闭窗口的方法 windowClosing(frame); &#125; //关闭窗口的方法 private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;//自定义类来实现接口ActionListenerclass MyActionListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 两个按钮共用一个事件 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestActionEvent02 &#123; public static void main(String[] args) &#123; //俩按钮实现一个事件 Frame frame = new Frame(); Button button1 = new Button(&quot;start&quot;); Button button2 = new Button(&quot;stop&quot;); //自定义类来实现事件监听 MyMonitor myActionListener = new MyMonitor(); //按钮添加监听 button1.addActionListener(myActionListener); button2.addActionListener(myActionListener); //frame添加button frame.add(button1, BorderLayout.NORTH); frame.add(button2, BorderLayout.SOUTH); //frame属性 frame.pack(); frame.setVisible(true); windowClosing(frame); &#125; private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;class MyMonitor implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;按钮getCommand:&quot; + e.getActionCommand()); &#125;&#125; 注： 优先用setActionCommand()，其次才是Button的标签 1button1.setActionCommand(&quot;s&quot;); 输入框监听TextField12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.linsip.lesson02;import cn.linsip.lesson01.TestFrame;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestText &#123; public static void main(String[] args) &#123; //启动 new MyFrame(); &#125;&#125;//我们用自定义类来封装Frameclass MyFrame extends Frame &#123; public MyFrame() &#123; //添加文本框 TextField textField = new TextField(); add(textField); //监听文本框输入的文字 MyMonitor2 myMonitor2 = new MyMonitor2(); textField.addActionListener(myMonitor2); //设置替换编码 //textField.setEchoChar(&#x27;*&#x27;); //设置大小，可见性等等 pack(); setVisible(true); window &#125; private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;class MyMonitor2 implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; TextField testField = (TextField) e.getSource();//事件获得的资源返回的是一个对象，强转为文本域 System.out.println(testField.getText());//获得文本框内容并打印 testField.setText(&quot;&quot;);//设置文本框内容为空 &#125;&#125; 简易的计算器，组合+内部类回归复习 OOP原则：组合，大于继承 组合 1234567public class A extends B&#123; &#125;public class A&#123; private B b;&#125; 练习 加法计算器 如图 思路： 根据拿到前两个数值，返回第三个数值 如何拿到前两个数值 如何返回第三个数值 进一步优化代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;//main函数用于启动或者测试程序public class TestCalc &#123; public static void main(String[] args) &#123; Calc calc = new Calc(); &#125;&#125;//自定义一个计算器类class Calc extends Frame &#123; public Calc() &#123; //3个文本框 TextField text1 = new TextField(20); TextField text2 = new TextField(20); TextField text3 = new TextField(20); //一个按钮+事件 Button button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor3(text1, text2, text3)); //一个标签 Label label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125;&#125;//自定义一个监听器class MyMonitor3 implements ActionListener &#123; //构造方法拿到这三个值 private TextField text1, text2, text3; public MyMonitor3(TextField text1, TextField text2, TextField text3) &#123; this.text1 = text1; this.text2 = text2; this.text3 = text3; &#125; @Override public void actionPerformed(ActionEvent e) &#123; //按下按钮事件e，1获取前两个文本框内容， int num1 = Integer.parseInt(text1.getText()); int num2 = Integer.parseInt(text2.getText()); //2计算返回值到第三个文本框 text3.setText(&quot;&quot; + (num1 + num2)); //,3清除前两个框 text1.setText(&quot;&quot;); text2.setText(&quot;&quot;); &#125;&#125; 完全面向对象的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestCalc2 &#123; public static void main(String[] args) &#123; new Calc2().loadCalc(); &#125;&#125;class Calc2 extends Frame &#123; TextField text1, text2, text3; Button button; Label label; public void loadCalc() &#123; //3个文本框 text1 = new TextField(20); text2 = new TextField(20); text3 = new TextField(20); //一个按钮+事件 button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor4(this)); //一个标签 label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125;&#125;class MyMonitor4 implements ActionListener &#123; //构造方法拿到这个对象 private Calc2 calc2 = null; public MyMonitor4(Calc2 calc2) &#123; this.calc2 = calc2; &#125; @Override public void actionPerformed(ActionEvent e) &#123; //1获取前两个文本框内容， //2计算返回值到第三个文本框 //3清除前两个框 int num1 = Integer.parseInt(calc2.text1.getText()); int num2 = Integer.parseInt(calc2.text2.getText()); calc2.text3.setText(&quot;&quot; + (num1 + num2)); calc2.text1.setText(&quot;&quot;); calc2.text2.setText(&quot;&quot;); &#125;&#125; 内部类写法 内部类可以直接访问外部类的属性和方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestCalc2 &#123; public static void main(String[] args) &#123; new Calc2().loadCalc(); &#125;&#125;class Calc2 extends Frame &#123; TextField text1, text2, text3; Button button; Label label; public void loadCalc() &#123; //3个文本框 text1 = new TextField(20); text2 = new TextField(20); text3 = new TextField(20); //一个按钮+事件 button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor4()); //一个标签 label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125; //内部类 private class MyMonitor4 implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; //1获取前两个文本框内容， //2计算返回值到第三个文本框 //3清除前两个框 int num1 = Integer.parseInt(calc2.text1.getText()); int num2 = Integer.parseInt(calc2.text2.getText()); calc2.text3.setText(&quot;&quot; + (num1 + num2)); calc2.text1.setText(&quot;&quot;); calc2.text2.setText(&quot;&quot;); &#125;&#125;&#125; 画笔12345678910111213141516171819202122232425package cn.linsip.lesson03;import java.awt.*;public class TestPaint &#123; public static void main(String[] args) &#123; new Paint().loadFrame(); &#125;&#125;class Paint extends Frame &#123; public void loadFrame() &#123; setBounds(200, 200, 400, 400); setVisible(true); &#125; @Override public void paint(Graphics g) &#123; //g.setColor(Color.ORANGE); g.drawOval(100, 100, 200, 200); g.fillOval(100, 100, 200, 200); //还原画笔默认颜色 &#125;&#125; 鼠标监听目的：想要实现鼠标画画 思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.linsip.lesson03;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.util.ArrayList;import java.util.Iterator;/*鼠标监听事件 */public class TestMouseListener &#123; public static void main(String[] args) &#123; new Myframe(&quot;画图&quot;); &#125;&#125;class Myframe extends Frame &#123; private ArrayList points; //画画需要画笔，需要监听鼠标位置，需要用集合存储 public Myframe(String title) &#123; super(title); setBounds(100, 100, 400, 400); //存鼠标点击的位置 points = new ArrayList&lt;&gt;(); setVisible(true); //鼠标监听器针对这个窗口 addMouseListener(new MyMouseListener()); &#125; @Override public void paint(Graphics g) &#123; //画画,监听鼠标的事件 Iterator iterator = points.iterator(); while (iterator.hasNext()) &#123; Point point = (Point) iterator.next(); g.setColor(Color.BLUE); g.fillOval(point.x, point.y, 10, 10); &#125; &#125; //添加这个点到界面上 public void addPoint(Point point) &#123; points.add(point); &#125; //适配器模式 private class MyMouseListener extends MouseAdapter &#123; //鼠标 按下 弹起 按住不放 @Override public void mousePressed(MouseEvent e) &#123; Myframe myframe = (Myframe) e.getSource(); //我们点击的时候就会产生一个点 //这个点就是鼠标点击的点 myframe.addPoint(new Point(e.getX(), e.getY())); //每次点击鼠标都要重画一次 myframe.repaint(); &#125; &#125;&#125; 窗口监听12345678910111213141516171819202122232425262728293031323334353637package cn.linsip.lesson03;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestWindow &#123; public static void main(String[] args) &#123; new WindowFrame(); &#125;&#125;class WindowFrame extends Frame&#123; public WindowFrame()&#123; setBackground(Color.BLUE); setBounds(100,100,400,400); setVisible(true); this.addWindowListener( new WindowAdapter() &#123; //关闭窗口 @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;正在关闭&quot;); System.exit(0); &#125; //激活窗口 @Override public void windowActivated(WindowEvent e) &#123; System.out.println(&quot;已进入当前窗口&quot;); &#125; &#125; ); &#125;&#125; 键盘监听12345678910111213141516171819202122232425262728293031package cn.linsip.lesson03;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;public class TestKeyListener &#123; public static void main(String[] args) &#123; new MyFrame(); &#125;&#125;class MyFrame extends Frame&#123; public MyFrame()&#123; setBounds(0, 0,400,400); setBackground(Color.yellow); setVisible(true); this.addKeyListener(new KeyAdapter() &#123; //键盘按压 @Override public void keyPressed(KeyEvent e) &#123; //获得按压的键 int keyCode = e.getKeyCode(); System.out.println(keyCode); if (keyCode == KeyEvent.VK_UP) &#123; System.out.println(&quot;UP&quot;); &#125; &#125; &#125;); &#125;&#125; Swing窗口、面板123456789101112131415161718192021package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;public class JFrameDemo01 &#123; public void init()&#123; JFrame jFrame = new JFrame(&quot;第一个JFrame窗口&quot;); jFrame.setBounds(0,0,400,400); jFrame.setVisible(true); JLabel jLabel = new JLabel(&quot;我的第一个JFrame窗口&quot;,SwingConstants.CENTER);//建一个label放在容器中间 jFrame.add(jLabel); jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//添加窗口关闭，默认隐藏 jFrame.getContentPane().setBackground(Color.cyan); &#125; public static void main(String[] args) &#123; new JFrameDemo01().init(); &#125;&#125; 弹窗12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class DialogDemo01 extends JFrame &#123; public DialogDemo01() &#123; this.setBounds(0, 0, 200, 200); this.setVisible(true); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); Container contentPane = this.getContentPane(); contentPane.setLayout(null); JButton jButton = new JButton(&quot;弹窗&quot;); jButton.setBounds(10, 10, 80, 50); jButton.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; new MyDialog(); &#125; &#125;); contentPane.add(jButton); &#125; public static void main(String[] args) &#123; new DialogDemo01(); &#125;&#125;class MyDialog extends JDialog &#123; public MyDialog() &#123; this.setVisible(true); this.setBounds(100, 100, 200, 200); Container contentPane = this.getContentPane(); //contentPane.setLayout(null); contentPane.add(new JLabel(&quot;弹窗警告&quot;)); &#125;&#125; 标签构造方法 1new JLabel(&quot;xxx&quot;) Icon如何画一个标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;/*图标，继承Frame类，实现Icon接口 */public class IconDemo01 extends JFrame implements Icon &#123; //属性：宽高 private int width; private int height; //构造器 public IconDemo01() &#123; &#125; public IconDemo01(int width, int height) &#123; this.width = width; this.height = height; &#125; //初始化方法 public void init() &#123; setBounds(0, 0, 800, 600); //图标放在标签上 IconDemo01 iconDemo01 = new IconDemo01(15,15); JLabel jLabel = new JLabel(&quot;图标&quot;, iconDemo01 , SwingConstants.CENTER); Container container = getContentPane(); container.add(jLabel); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; //main方法 public static void main(String[] args) &#123; //通过调用new IconDemo01()的init()方法来 new IconDemo01().init(); &#125; //重写接口Icon的方法 @Override public void paintIcon(Component c, Graphics g, int x, int y) &#123; //画图标，画一个圆 g.fillOval(x, y, width, height); &#125; @Override public int getIconWidth() &#123; return width; &#125; @Override public int getIconHeight() &#123; return height; &#125;&#125; 图片标签ImageIcon1234567891011121314151617181920212223242526272829303132package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;import java.net.URL;public class ImageIconDemo extends JFrame &#123; public ImageIconDemo() &#123; //获取图片的地址 URL url = ImageIconDemo.class.getResource(&quot;Hush a by little girl.jpg&quot;); ImageIcon imageIcon = new ImageIcon(url); //new JLabel标签 JLabel jLabel = new JLabel(); jLabel.setIcon(imageIcon); jLabel.setHorizontalAlignment(SwingConstants.CENTER); //把JLabel标签放面板上 Container container = getContentPane(); container.add(jLabel); pack(); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new ImageIconDemo(); &#125;&#125; 面板JPanel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JPanelDemo extends JFrame &#123; public JPanelDemo() &#123; //容器 Container container = getContentPane(); container.setLayout(new GridLayout(2,2, 10, 10)); //面板 JPanel jPanel1 = new JPanel(new GridLayout(1, 3)); JPanel jPanel2 = new JPanel(new GridLayout(1, 2)); JPanel jPanel3 = new JPanel(new GridLayout(2, 1)); JPanel jPanel4 = new JPanel(new GridLayout(3, 2)); //添加jButton按钮到JPanel面板 jPanel1.add(new JButton(&quot;1&quot;)); jPanel1.add(new JButton(&quot;1&quot;)); jPanel1.add(new JButton(&quot;1&quot;)); jPanel2.add(new JButton(&quot;2&quot;)); jPanel2.add(new JButton(&quot;2&quot;)); jPanel3.add(new JButton(&quot;3&quot;)); jPanel3.add(new JButton(&quot;3&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); //添加jPanel面板到容器中 container.add(jPanel1); container.add(jPanel2); container.add(jPanel3); container.add(jPanel4); setBounds(0, 0, 400, 400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JPanelDemo(); &#125;&#125; JScroll面板 1234567891011121314151617181920212223242526272829package cn.linsip.lesson01;import javax.swing.*;import java.awt.*;public class JScrollDemo extends JFrame &#123; public JScrollDemo() &#123; Container container = getContentPane(); //文本域 JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(&quot;Hello World!&quot;); JScrollPane jScrollPane = new JScrollPane(jTextArea); container.add(jScrollPane); setBounds(0, 0, 400, 400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JScrollDemo(); &#125;&#125; 按钮图片按钮 1234567891011121314151617181920212223242526272829303132package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;import java.net.URL;public class JButtonDemo01 extends JFrame &#123; public JButtonDemo01() &#123; Container container = getContentPane(); URL resource = JButtonDemo01.class.getResource(&quot;wechat.jpg&quot;); Icon icon = new ImageIcon(resource); JButton jButton = new JButton(); jButton.setIcon(icon); jButton.setToolTipText(&quot;图片按钮&quot;); container.add(jButton); setVisible(true); setSize(400,400); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo01(); &#125;&#125; 单选按钮 1234567891011121314151617181920212223242526272829303132333435363738package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JButtonDemo02 extends JFrame &#123; public JButtonDemo02() &#123; Container container = getContentPane(); //URL resource = JButtonDemo01.class.getResource(&quot;wechat.jpg&quot;); //Icon icon = new ImageIcon(resource); JRadioButton jRadioButton1 = new JRadioButton(&quot;jRB1&quot;); JRadioButton jRadioButton2 = new JRadioButton(&quot;jRB2&quot;); JRadioButton jRadioButton3 = new JRadioButton(&quot;jRB3&quot;); ButtonGroup buttonGroup = new ButtonGroup(); buttonGroup.add(jRadioButton1); buttonGroup.add(jRadioButton2); buttonGroup.add(jRadioButton3); container.add(jRadioButton1,BorderLayout.CENTER); container.add(jRadioButton2,BorderLayout.NORTH); container.add(jRadioButton3,BorderLayout.SOUTH); setSize(400,400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo02(); &#125;&#125; 复选按钮 1234567891011121314151617181920212223242526272829package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JButtonDemo03 extends JFrame &#123; public JButtonDemo03() &#123; Container container = getContentPane(); JCheckBox jCheckBox1 = new JCheckBox(&quot;jCheckBox1&quot;); JCheckBox jCheckBox2 = new JCheckBox(&quot;jCheckBox2&quot;); JCheckBox jCheckBox3 = new JCheckBox(&quot;jCheckBox3&quot;); container.add(jCheckBox1,BorderLayout.NORTH); container.add(jCheckBox2,BorderLayout.CENTER); container.add(jCheckBox3,BorderLayout.SOUTH); setSize(400,400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo03(); &#125;&#125; 列表下拉框 12345678910111213141516171819202122232425262728package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestComboboxDemo01 extends JFrame &#123; public TestComboboxDemo01() &#123; Container container = getContentPane(); JComboBox jComboBox = new JComboBox(); jComboBox.addItem(&quot;1&quot;); jComboBox.addItem(&quot;2&quot;); jComboBox.addItem(&quot;3&quot;); jComboBox.addItem(null); container.add(jComboBox); setSize(100,100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestComboboxDemo01(); &#125;&#125; 列表框 123456789101112131415161718192021222324252627282930313233package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;import java.util.Vector;public class TestComboboxDemo02 extends JFrame &#123; public TestComboboxDemo02() &#123; Container container = getContentPane(); //生成列表内容 //String[] strings = &#123;1 ,2 , 3&#125;; Vector contents = new Vector(); JList jList = new JList(contents); contents.add(&quot;111&quot;); contents.add(&quot;222&quot;); contents.add(&quot;333&quot;); container.add(jList); setSize(100,100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestComboboxDemo02(); &#125;&#125; 应用场景 选择地区，一般是单个选项 列表展示信息，一般是动态扩容 文本框文本框 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo01 extends JFrame &#123; public TestTextDemo01() throws HeadlessException &#123; Container container = getContentPane(); JTextField jTextField1 = new JTextField(&quot;jTextField1&quot;); JTextField jTextField2 = new JTextField(&quot;jTextField2&quot;); container.add(jTextField1, BorderLayout.NORTH); container.add(jTextField2, BorderLayout.SOUTH); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo01(); &#125;&#125; 密码框 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo02 extends JFrame &#123; public TestTextDemo02() &#123; Container container = getContentPane(); JPasswordField jPasswordField = new JPasswordField(); jPasswordField.setEchoChar(&#x27;*&#x27;); container.add(jPasswordField); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo02(); &#125;&#125; 文本域 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo03 extends JFrame &#123; public TestTextDemo03() &#123; Container container = getContentPane(); JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(&quot;Hello World!&quot;); JScrollPane jScrollPane = new JScrollPane(jTextArea); container.add(jScrollPane); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo03(); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java, GUI","slug":"Java-GUI","permalink":"http://example.com/tags/Java-GUI/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2021-04-28T21:57:24.000Z","updated":"2021-05-11T06:12:23.054Z","comments":true,"path":"2021/04/29/Markdown语法/","link":"","permalink":"http://example.com/2021/04/29/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。","text":"Markdown语法Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 标题：#+空格+标题名称：一级标题 ##+空格+标题名称：二级标题 … 字体：粗体 **在字的两边加** 斜体 *在字的两边加* 删除线 ~~在字左右加~~ 引用： &gt;+空格就是引用 分割线： ---或*** 图片： !+[这里面写图片名称]+(这里面写图片地址) 超链接：B站 [这里网站名称]+(这里写网址) 列表 1+.+空格 -+空格 表格：| 表头 | 表头|| --- | --- || 内容 | 内容 | 代码：三个` esc下面的按键（英文状态下） 12345public class Hello&#123; public static void main (String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 代办事项-+空格+ [空格]-+空格+ [x] 事项1 事项2 数学公式$$y=2x^2+1​$$ $$E=mc^2$$ $$\\sum_{i=1}^n a_i=0$$ 快捷键window + e esc下面的按键（英文状态下）","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"Hexo博客的搭建部署","slug":"Hexo博客的搭建部署","date":"2021-04-19T16:21:24.000Z","updated":"2021-04-30T19:51:28.350Z","comments":true,"path":"2021/04/20/Hexo博客的搭建部署/","link":"","permalink":"http://example.com/2021/04/20/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/","excerpt":"Hexo博客搭建教程其实Hexo官方文档更详尽，这里就按步骤写起 搭建环境下载安装Git 到Git官网下载合适版本的Git，并安装 检测安装是否成功 1git --version//查看Git版本","text":"Hexo博客搭建教程其实Hexo官方文档更详尽，这里就按步骤写起 搭建环境下载安装Git 到Git官网下载合适版本的Git，并安装 检测安装是否成功 1git --version//查看Git版本 Git安装成功后可以用Git Bash来进行命令行操作 下载安装Note.js 到Note.js中文官网下载合适的版本，并安装 检测是否安装成功 12node -v//查看note版本npm -v//查看npm版本 搭建本地博客安装Hexo 打开Git Bash，输入下面的命令 1npm install -g hexo-cli 检测是否安装成功 1hexo -v 博客初始化 新建一个文件夹作为博客的目录，例如将博客目录设置为myblog 1hexo init myblog 初始化博客 12cd myblognpm install 博客本地效果 Git Bash执行下面的命令 12hexo -g//生成静态页面hexo server//本地预览 查看本地博客效果 将博客部署到Github创建个人Github仓库 注册一个Github账号，并登录 新建一个Github仓库，并命名为yourname.github.io。必须按此格式命名，这里yourname可以自定义，比如我的仓库名Linsip.github.io 配置SSH Git Bash输入下面的命令，生成密钥 12git config --global user.name &quot;你的github账户名字&quot;git config --global user.email &quot;你的github邮箱&quot; 检测输入的用户名与邮箱是否正确 12git config user.namegit config user.email 输入下面命令创建SSH密钥 1ssh-keygen -t rsa -C &quot;youremail&quot; 上传SSH密钥到Github 部署代码到Github上 找到并打开配置文件，修改其内容 Git Bash输入下面命令，安装hexo-deployer-git 1npm install hexo-deployer-git --save// 继续执行下面的命令 123hexo clean//hexo generate//hexo deploy// 打开网址http://yourname.github.io就可以看到你自己搭建的博客。这里的yourname就是你Github仓库的名字 设置个人域名购买域名待完善 Hexo博客常用命令新建博客目录1hexo init &lt;folder&gt; 新建文章123hexo new [layout] &lt;title&gt;//例如hexo n &quot;我的第一篇博客&quot; 生成静态页面1hexo generate 部署内容到网站1hexo deploy 启用本地预览1hexo server Hexo博客常见问题更换博客主题到Hexo官网找到自己喜欢的主题， 让后输入以下命令 1","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Java, GUI","slug":"Java-GUI","permalink":"http://example.com/tags/Java-GUI/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}