{"meta":{"title":"Linsip","subtitle":"","description":"","author":"Linsip","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-05-11T15:59:37.000Z","updated":"2021-05-11T15:59:37.000Z","comments":false,"path":"js/aplayer.js","permalink":"http://example.com/js/aplayer.js","excerpt":"","text":"!(function() { var oldLoadAp = window.onload; window.onload = function () { oldLoadAp && oldLoadAp(); new APlayer({ container: document.getElementById('aplayer'), fixed: true, autoplay: false, loop: 'all', order: 'random', //theme: '#b7daff', preload: 'auto', listFolded: true, listMaxHeight: 90, lrcType: 3, audio: [ { name: '彼女は旅に出る - 鎖那', artist: 'Hush a by little girl', url: '/songs/彼女は旅に出る - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/彼女は旅に出る - 鎖那.lrc' }, { name: '鍵っ子 - 鎖那', artist: 'Hush a by little girl', url: '/songs/鍵っ子 - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/鍵っ子 - 鎖那.lrc' }, { name: 'シュテルン - 鎖那', artist: 'Hush a by little girl', url: '/songs/シュテルン - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/シュテルン - 鎖那.lrc' }, { name: 'オオカミと少女 - 鎖那', artist: 'Hush a by little girl', url: '/songs/オオカミと少女 - 鎖那.mp3', cover: '/img/Hush a by little girl.jpg', lrc: '/lrc/オオカミと少女 - 鎖那.lrc' } ] }); } })();"},{"title":"","date":"2021-05-01T05:55:57.927Z","updated":"2021-05-01T05:55:57.927Z","comments":false,"path":"js/daovoice.js","permalink":"http://example.com/js/daovoice.js","excerpt":"","text":"!(function() { var appId = '0d1240ec'; (function (i, s, o, g, r, a, m) { i['DaoVoiceObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments); }; i[r].l = 1 * new Date(); a = s.createElement(o); m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; a.charset = 'utf-8'; m.parentNode.insertBefore(a, m); })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + '//widget.daovoice.io/widget/' + appId + '.js', 'daovoice'); daovoice('init', { app_id: appId, }); daovoice('update'); })();"},{"title":"about","date":"2021-04-28T15:59:57.000Z","updated":"2021-05-11T16:22:12.921Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我有故事，你有酒吗？"},{"title":"categories","date":"2021-05-11T12:34:16.000Z","updated":"2021-05-11T12:37:51.841Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"LG G7ThinQ自定义谷歌按键","slug":"LG-g7自定义谷歌按键","date":"2021-05-13T13:40:03.000Z","updated":"2021-05-17T06:45:06.439Z","comments":true,"path":"2021/05/13/LG-g7自定义谷歌按键/","link":"","permalink":"http://example.com/2021/05/13/LG-g7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%B7%E6%AD%8C%E6%8C%89%E9%94%AE/","excerpt":"","text":"LG G7ThinQ自定义谷歌按键这里拿改为截图键为例 下载mt管理器，并授予root权限，进入根目录 以文本方式打开/system/usr/keylayout文件夹下的gpio-keys.kl文件 往下找到key 377，改为SYSRQ，即系统截图 保存该文件，重启手机，完成修改 你可能还需要： 按键 作用 CAMERA 拍照 FOCUS 拍照对焦 SYSRQ 系统截图 MEDIA_PLAY_PAUSE 音乐播放暂停 MEDIA_NEXT 下一曲 MEDIA_PREVIOUS 上一曲 VOLUME_MUTE 静音 VOLUME_UP 音量增加 VOLUME_DOWN 音量减少 POWER 电源 BACK 返回 MENU 菜单 HEMO 主页 CALL 拨号","categories":[{"name":"玩机","slug":"玩机","permalink":"http://example.com/categories/%E7%8E%A9%E6%9C%BA/"}],"tags":[{"name":"LG G7ThinQ","slug":"LG-G7ThinQ","permalink":"http://example.com/tags/LG-G7ThinQ/"}]},{"title":"IO流","slug":"IO流","date":"2021-05-12T10:41:31.000Z","updated":"2021-05-14T09:21:39.365Z","comments":true,"path":"2021/05/12/IO流/","link":"","permalink":"http://example.com/2021/05/12/IO%E6%B5%81/","excerpt":"I/O输入/输出(Input/Output)，分为IO设备和IO接口两个部分。 在POSIX兼容的系统上，例如Linux系统 [1] ，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O，异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。","text":"IO流什么是IO I/O输入/输出(Input/Output)，分为IO设备和IO接口两个部分。 在POSIX兼容的系统上，例如Linux系统 [1] ，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O，异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。 百度百科 我们把数据的传输看为数据的流动，按照流动的方向，以内存为基准，分为输入input和输出output。即流向内存是输入流，流出内存是输出流。 IO的分类 根据数据的流向分为 输入流：把数据从其他设备读取到内存中 输出流：把数据从内存中写入到其他设备 根据数据类型分为 字节流：以字节为单位，读写数据的流 字符流：以字符为单位，读写数据的流 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节流一切皆为字节 一切数据都是以二进制数字的形式保存的，都是一个个的字节。字节流可以传输任何数据 字节输出流 写出字节数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445package io;import java.io.FileOutputStream;import java.io.IOException;/*java.io.OutputStream 字节输出流此抽象类是表示输出字节流的所有类的超类。输出流接受输出字节并将这些字节发送到某个接收器。成员方法 void close() 关闭此输出流并释放与此流有关的所有系统资源。 void flush() 刷新此输出流并强制写出所有缓冲的输出字节。 void write(byte[] b) 将 b.length个字节从指定的 byte 数组写入此输出流。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 abstract void write(int b) 将指定的字节写入此输出流。java.io.FileOutputStream extends OutputStream FileOutputStream 文件输出流 构造方法 FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。 FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 ... 构造方法的作用： 创建一个FileOutputStream对象 根据构造方法中传递的文件路径、文件名，创造一个空的文件 把FileOutputStream对象指向该文件 写入数据的原理： Java程序--&gt;JVM--&gt;OS--&gt;OS中的写入数据方法--&gt;将数据写入文件 字节输出流的使用 1.创建一个FileOutputStream对象，构造方法中传入写入数据的目的地 2.调用FileOutputStream对象中的write方法，把数据写入到文件 3.释放资源（凡是涉及到IO流的使用的都会占用一定的内存资源，使用完毕一定要记得关闭，节省系统资源，提升程序效率） */public class IODemo01 &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个FileOutputStream对象，构造方法中传入写入数据的目的地 FileOutputStream fos = new FileOutputStream(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\src\\\\io\\\\a.txt&quot;); //2.调用FileOutputStream对象中的write方法，把数据写入到文件 fos.write(97); //3.释放资源（凡是涉及到IO流的使用的都会占用一定的内存资源，使用完毕一定要记得关闭，节省系统资源，提升程序效率） fos.close(); &#125;&#125; 文件存储原理 文本编辑器读取文件原理 在任意文本编辑器中，打开文件都会查询编码表、 0-127 查询ASCII码表 ​ 97–a ​ ··· 其他 查询当前系统默认码表，中文系统GBK码表","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"常用类库API","slug":"常用类库API","date":"2021-05-12T10:32:19.000Z","updated":"2021-05-17T06:26:30.142Z","comments":true,"path":"2021/05/12/常用类库API/","link":"","permalink":"http://example.com/2021/05/12/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93API/","excerpt":"","text":"Java常用类库APIJDK1.8中文帮助文档 JDK1.8英文帮助文档 Object概述java.lang.Object类是Java语言的根类，是所有类的父类，所有类都可以使用它的方法 一个类如果没有显示的定义继承，那么就会默认继承Object类 123public class Hello /*extend Object*/&#123; //...&#125; 所有对象（包括数组）都实现这个类的方法 这里我们重点掌握Object的两个方法： toString方法 equals方法 toString方法例如 我们先定义一个Person类 12345678910111213141516171819202122232425262728293031package object;//我们先定义一个标准的类,这个类默认继承Object类public class Person &#123; private int age; private String name; public Person() &#123; &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后实例化Person，调用person对象的方法toString 1234567891011package object;public class ObjectDemo01 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); String s1 = p1.toString(); System.out.println(s1);//object.Person@4f3f5b24 打印的是这个对象的包名+类名+@地址值 System.out.println(p1);//object.Person@4f3f5b24 直接打印对象名就相当于调用了Object类的toString方法 &#125;&#125; 重写toString方法如果我们想要打印对象的属性 我们就必须重写对象的toString方法 123456789101112131415161718192021222324252627282930313233343536373839package object;//我们先定义一个标准的类,这个类默认继承Object类public class Person &#123; private int age; private String name; public Person() &#123; &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 在运行下面这段代码，打印的就是重写的toString方法的内容 123456789101112package object;public class ObjectDemo01 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); String s1 = p1.toString(); System.out.println(s1);//Person&#123;age=0, name=&#x27;null&#x27;&#125; System.out.println(p1);//Person&#123;age=0, name=&#x27;null&#x27;&#125; &#125;&#125; 如何判断一个类有没有重写toString方法，直接打印这个类的名字就可以知道 没有重写：打印的是这个对象的包路径加地址值 重写：按照其重写的方法进行打印 例如： 123456789101112131415161718192021package object;import java.util.ArrayList;import java.util.Random;import java.util.Scanner;public class ObjectDemo02 &#123; public static void main(String[] args) &#123; Random random = new Random(); System.out.println(random);//java.util.Random@4f3f5b24 Scanner scanner = new Scanner(System.in); System.out.println(scanner);//java.util.Scanner[delimiters=\\p&#123;javaWhitespace&#125;+][position=0][match valid=false][need input=false][source closed=false][skipped=false][group separator=\\x&#123;2c&#125;][decimal separator=\\x&#123;2e&#125;][positive prefix=][negative prefix=\\Q-\\E][positive suffix=][negative suffix=][NaN string=\\QNaN\\E][infinity string=\\Q∞\\E] ArrayList&lt;Object&gt; objects = new ArrayList&lt;&gt;(); objects.add(1); objects.add(2); System.out.println(objects);//[1, 2] &#125;&#125; equals方法equals方法：比较两个对象的地址值是否相同 之前在toString那里定义了一个Person类，这里我们这里来new两个Person对象 12345678910111213141516package object;public class ObjectDemo03 &#123; public static void main(String[] args) &#123; Person p1 = new Person(10,&quot;小明&quot;); Person p2 = new Person(9, &quot;小红&quot;); //这里我们将Person类里面重写toString方法的代码注释掉 System.out.println(p1);//object.Person@4f3f5b24 System.out.println(p2);//object.Person@15aeb7ab boolean equals = p1.equals(p2); System.out.println(equals);//false &#125;&#125; 重写equals方法我们想要比较两个对象的属性 就必须重写equals方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package object;//我们先定义一个标准的类,这个类默认继承Object类public class Person &#123; private int age; private String name; public Person() &#123; &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; /*@Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;*/ @Override public boolean equals(Object obj) &#123; /* 这里隐含着一个多态 equals方法的参数传递的是Object类型的参数，无法直接调用其子类对象的属性、方法 这里我们先要强转obj为Person类 */ Person p = (Person) obj; boolean b = this.name.equals(p.name) &amp;&amp; this.age == p.age; return b; &#125;&#125; 再运行以下代码 1234567891011121314151617package object;public class ObjectDemo03 &#123; public static void main(String[] args) &#123; Person p1 = new Person(10,&quot;小明&quot;); Person p2 = new Person(9, &quot;小红&quot;); Person p3 = new Person(9, &quot;小红&quot;); //这里我们将Person类里面重写toString方法的代码注释掉 System.out.println(p2);//object.Person@4f3f5b24 System.out.println(p3);//object.Person@15aeb7ab boolean equals = p2.equals(p3); System.out.println(equals);//true &#125;&#125; 这里的p2.equals(p3)就比较的是其属性是否相同 注 我们重写的这个equals方法只能比较的是两个相同类型的对象的属性 不能比较的是两个不同类型的对象，否则会报一个异常 1234567891011121314151617181920212223package object;import java.util.Random;public class ObjectDemo03 &#123; public static void main(String[] args) &#123; Person p1 = new Person(10,&quot;小明&quot;); Person p2 = new Person(9, &quot;小红&quot;); Person p3 = new Person(9, &quot;小红&quot;); //这里我们将Person类里面重写toString方法的代码注释掉 System.out.println(p2);//object.Person@4f3f5b24 System.out.println(p3);//object.Person@15aeb7ab boolean equals = p2.equals(p3); System.out.println(equals);//true Random r1 = new Random(); boolean b1 = p1.equals(r1); System.out.println(b1);//java.lang.ClassCastException 类转换异常 &#125;&#125; 所以要在重写的equals方法里加一个判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package object;//我们先定义一个标准的类,这个类默认继承Object类public class Person &#123; private int age; private String name; public Person() &#123; &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; /*@Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;*/ @Override public boolean equals(Object obj) &#123; /* 这里隐含着一个多态 equals方法的参数传递的是Object类型的参数，无法直接调用其子类对象的属性、方法 这里我们先要强转obj为Person类 */ if (obj instanceof Person) &#123; Person p = (Person) obj; boolean b = this.name.equals(p.name) &amp;&amp; this.age == p.age; return b; &#125; //不是Person类型的就直接返回false return false; &#125;&#125; 思考：如何进一步优化？ 我们看Idea给我们重写的方法 123456789101112131415161718@Override public boolean equals(Object o) &#123; if (this == o) return true; //getClass这里用的是反射，之后在反射里面会学 if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; &#125; @Override public int hashCode() &#123; int result = age; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; 我们再看java7以后重写的equals方法 123456789101112@Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name);//这里比较两个对象的name直接用的Objects类的equals方法 &#125; @Override public int hashCode() &#123; return Objects.hash(age, name); &#125; Objects类JDK7添加了一个Objects工具类，它提供了一些方法操作对象，它由一些静态的方法组成，这些方法是空指针安全的或容忍空指针的，它用于计算对象的hashCode，返回对象的字符串表示形式，比较两个对象。 比较两个对象 1public static boolean equals(Object a, Object b); 示例 1234567891011121314151617package object;import java.util.Objects;public class ObjectsDemo01 &#123; public static void main(String[] args) &#123; String s1 = null; String s2 = &quot;abc&quot;; /*boolean b1 = s1.equals(s2);//java.lang.NullPointerException 空指针异常 System.out.println(b1);*/ boolean b2 = Objects.equals(s1, s2); System.out.println(b2);//false &#125;&#125; Object总结Object类 介绍 Object类是所有类的父类（所有类都会直接或者间接继承Object类） Object类提供了一些方法 toString方法 作用：打印对象的信息 重写前：打印的是包名+类名+@地址值 重写后：按重写的方法打印 equals方法 作用：判断两个对象是否相同 重写前：比较的是两个对象的地址值 重写后：按重写的方法进行比较 Objects类 equals方法 也是比较两个对象是否相同，添加了一个非空判断，防止空指针异常 Math概述java.lang.Math类包含用于执行基本数学运算的方法 其所有方法均是静态方法，可以直接类名.方法名调用 常用方法 1public static double abs(double num);//绝对值 1public static double ceil(double nun);//向上取整 1public static double floor(double nun);//向下取整 1public static long round(double num);//四舍五入 基本运算方法绝对值 1double d1 = Math.abs(-5);//5 向上取整 1double d2 = Math.ceil(3.1)//4 向下取整 1double d3 = Math.floor(1.9)//1 四舍五入 1long l1 = Math.round(4.5)//5 练习请使用Math相关的API，计算-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？ 123456789101112131415161718192021222324252627package math;//请使用Math相关的API，计算-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？public class MathDemo01 &#123; public static void main(String[] args) &#123; //定义一个最大值一个最小值 double max = 5.9; double min = -10.8; //定义一个数用于记数 int num = 0; //外层for循环用于获-10.8————5.9的整数，内层if判断绝对值是否大于6或小于2.1 for (double i = Math.ceil(min); i &lt;= max; i++) &#123; if (Math.abs(i) &gt; 6 || Math.abs(i) &lt; 2.1) &#123; //计数+1 num++; &#125; &#125; //打印结果 System.out.println(num); &#125;&#125; Random概念java.util.Random类用于生成随机数字 如何使用构造方法 1Random r = new Random(); 使用 获取一个随机的int数字 获取指定范围的随机数 12345678910111213141516package random;import java.util.Random;public class RandomDemo01 &#123; public static void main(String[] args) &#123; //new一个Random Random r1 = new Random(); //调用Random的nextInt()方法 int i = r1.nextInt(); System.out.println(i); &#125;&#125; 123456789101112131415package random;import java.util.Random;public class RandomDemo02 &#123; public static void main(String[] args) &#123; Random r1 = new Random(); for (int i1 = 0; i1 &lt; 10; i1++) &#123; int i = r1.nextInt(10);//[0,10) System.out.println(i); &#125; &#125;&#125; 练习根据给定的数字n，返回指定[1,n]之间的随机整数 1234567```猜数字小游戏：电脑生成一个指定范围的整数，用户来猜，才对结束程序```java File简介java.io.File类 文件和目录路径名的抽象表现形式 java把电脑的文件和文件夹封装成了一个File类，我们可以通过操作File类来使用文件和文件夹 File类的方法 创建文件或文件夹 删除文件或文件夹 获取文件或文件夹 对文件夹进行遍历 获取文件大小 File类是一个与系统无关的类，任何操作系统都可以使用这个File类的方法 记住三个单词 file：文件 directory：文件夹 path：路径 File类的静态成员变量示例代码 12345678910111213141516171819202122232425262728293031323334package file;import java.io.File;public class FileDemo01 &#123; public static void main(String[] args) &#123; /* static String pathSeparator 与系统相关的路径分隔符字符，为方便起见，表示为字符串。 static char pathSeparatorChar 与系统相关的路径分隔符。 static String separator 与系统相关的默认名称 - 分隔符字符，以方便的方式表示为字符串。 static char separatorChar 与系统相关的默认名称分隔符。 以后要操作路径不能把路径写死 windows C:\\a\\a.txt linux C:/a/a.txt 代码中 &quot;C:&quot;+File.separator+&quot;a&quot;+File.separator+&quot;a.txt&quot; */ String pathSeparator = File.pathSeparator; System.out.println(pathSeparator);//; 路径分隔符 windows; linux: String separator = File.separator; System.out.println(separator);//\\ 文件名称分隔符 windows\\ linux/ &#125;&#125; 绝对路径与相对路径绝对路径：一个完整的路径 ​ 以盘符开始的路径 ​ c:\\a.txt ​ 相对路径：一个简化的路径 ​ 相对于当前项目的根目录 ​ b.txt 注： 路径不区分大小写（windows）,Linux区分大小写 反斜杠表示转义字符，两个反斜杠表示一个普通的反斜杠 File类的构造方法 File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 File(URI uri) ：通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package file;import java.io.File;/*File(File parent, String child)从父抽象路径名和子路径名字符串创建新的 File实例。File(String pathname)通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。File(String parent, String child)从父路径名字符串和子路径名字符串创建新的 File实例。File(URI uri)通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。 */public class FileDemo02 &#123; public static void main(String[] args) &#123; show01(); show02(&quot;C:\\\\&quot;, &quot;a.txt&quot;); show03(); &#125; /* File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例。 参数： File parent 父路径 String child 子路径 好处： 父路径是File类，可以使用File类的方法进行操作 */ private static void show03() &#123; File parent = new File(&quot;C:\\\\&quot;); File file = new File(parent, &quot;a.txt&quot;); System.out.println(file);//C:\\a.txt &#125; /* File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例。 参数： String parent 父路径 String child 子路径 好处： 父路径和子路径可以单独书写，使用灵活 */ private static void show02(String parent, String child) &#123; File file = new File(parent, child); System.out.println(file);//C:\\a.txt &#125; /* File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 参数： String pathname 字符串的路径名称 路径名称可以是以文件结尾，也可以是以文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以存在，也可以不存在 创建File类对象，只是把字符串路径封装为File对象，不考虑路径真实情况 */ private static void show01() &#123; File f1 = new File(&quot;C:\\\\Users\\\\a.txt&quot;); System.out.println(f1);//C:\\Users\\a.txt 重写了Object的toString方法 File f2 = new File(&quot;C:\\\\Users&quot;); System.out.println(f2);//C:\\Users File f3 = new File(&quot;a.txt&quot;); System.out.println(f3);//a.txt &#125;&#125; 常用方法 获取功能的方法 public String getAbsolutePath()//返回绝对路径名称字符串 public String getPath()//返回路径名称字符串 public String getName()//返回文件或目录名称 public Long length()//返回文件大小 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package file;import java.io.File;import java.sql.SQLOutput;public class FileDemo03 &#123; public static void main(String[] args) &#123; show01(); show02(); show03(); show04(); &#125; /* public Long length()//返回文件大小 获取的是构造方法指向的文件大小 以字节为单位 */ private static void show04() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\背景图片1.jpg&quot;); long length = f1.length(); System.out.println(length);//450171 &#125; /* public String getName()//返回文件或目录名称 获取构造方法中传递的路径的结尾部分（文件或文件夹） */ private static void show03() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\a.txt&quot;); String name1 = f1.getName(); System.out.println(name1);//a.txt File f2 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode&quot;); String name2 = f2.getName(); System.out.println(name2);//JavaCode &#125; /* public String getPath()//返回路径名称字符串 获取构造方法中传递的路径 toString方法调用的就是getPath方法 源码： public String toString() &#123; return getPath(); &#125; */ private static void show02() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\src&quot;); File f2 = new File(&quot;a.txt&quot;); String p1 = f1.getPath(); String p2 = f2.getPath(); System.out.println(p1);//C:\\Users\\MaLin\\Desktop\\JavaCode\\src System.out.println(p2);//a.txt System.out.println(f1);//C:\\Users\\MaLin\\Desktop\\JavaCode\\src System.out.println(f1.toString());//C:\\Users\\MaLin\\Desktop\\JavaCode\\src &#125; /* public String getAbsolutePath()//返回绝对路径名称字符串 获取构造方法中传递的绝对路径 */ private static void show01() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\src&quot;); String absolutePath1 = f1.getAbsolutePath(); System.out.println(absolutePath1);//C:\\Users\\MaLin\\Desktop\\JavaCode\\src File f2 = new File(&quot;a.txt&quot;); String absolutePath2 = f2.getAbsolutePath(); System.out.println(absolutePath2);//C:\\Users\\MaLin\\Desktop\\JavaCode\\a.txt &#125;&#125; 判断功能的方法 public boolean exists()：File类表示的文件或文件夹是否存在 public boolean isFile() ：File类表示的是否是文件 public boolean isDirectory() ：File类表示的是否是文件夹 示例 1234567891011121314151617181920212223242526272829303132333435363738394041package file;import java.io.File;/*File类的判断功能方法 public boolean exists() public boolean isFile() public boolean isDirectory() 注意事项 isFile() isDirectory() 这两个方法使用前提：路径必须存在，否则都返回false 使用前最好用exists()方法判断一下路径是否存在 */public class FileDemo04 &#123; public static void main(String[] args) &#123; demo01(); &#125; private static void demo01() &#123; File file1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode&quot;); System.out.println(file1.exists());//true File file2 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode\\\\背景图片1.jpg&quot;); System.out.println(file2.exists());//true System.out.println(&quot;=======================================&quot;); if (file1.exists() &amp;&amp; file2.exists()) &#123; System.out.println(file1.isFile());//false System.out.println(file2.isFile());//ture System.out.println(file1.isDirectory());//false System.out.println(file2.isDirectory());//true &#125; &#125;&#125; 创建和删除功能的方法 public boolean createNewFile()：当且仅当该名称文件不存在时，创建一个新的空的文件。 public boolean delete()：删除由此File表示的文件或目录 public boolean mkdir()：创建由此File表示的文件夹 public boolean mkdirs()：创建由此File表示的目录，包括任何必须但不存在的父目录 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package file;import java.io.File;import java.io.IOException;public class FileDemo05 &#123; public static void main(String[] args) throws IOException &#123; //show01(); //show02(); show03(); &#125; /* public boolean delete() 删除构造方法中创建的文件或文件夹 返回值 false文件夹中有内容(文件或文件夹)不会删除文件夹 构造方法中不存在路径 true删除成功 注意事项 delete()方法会直接删除文件或文件夹，不会走回收站 */ private static void show03() &#123; File f1 = new File(&quot;a.txt&quot;); boolean b1 = f1.delete(); System.out.println(b1); File f2 = new File(&quot;a&quot;); boolean b2 = f2.delete(); System.out.println(b2); File f3 = new File(&quot;111&quot;); boolean b3 = f3.delete(); System.out.println(b3); &#125; /* public boolean mkdir() public boolean mkdirs() 返回值 false true 注意 此方法只能创建文件夹 */ private static void show02() &#123; File f1 = new File(&quot;a&quot;); boolean b1 = f1.mkdir(); System.out.println(b1);//true File f2 = new File(&quot;111\\\\222\\\\333&quot;); boolean b2 = f2.mkdirs(); System.out.println(b2);//true &#125; /* public boolean creatNewFile() 创建文件的路径和名称在构造方法中给出 返回值 false文件已存在，创建文件失败 true文件不存在，创建文件成功 注意事项 只能创建文件 创建文件的路径必须存在，否则会抛出异常 creatNewFile()这个方法声明抛出了IOException，我们调用这个方法要么throws这个异常，要么try catch这个异常 */ private static void show01() throws IOException &#123; File f1 = new File(&quot;1.txt&quot;); boolean b1 = f1.createNewFile(); System.out.println(&quot;b1:&quot; + b1); &#125;&#125; 遍历目录的方法 public String[] list()：返回一个String数组，表示该File类目录中的所有子文件或目录 public File[] listFile()：返回一个File数组，表示该File类目录的所有子文件或目录 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package file;import java.io.File;/*public String[] list()：返回一个String数组，表示该File类目录中的所有子文件或目录public File[] listFile()：返回一个File数组，表示该File类目录的所有子文件或目录list() listFile()方法遍历的是构造方法中传递的目录如果构造方法中传递的目录不存在或者传递的不是一个目录路径，会报空指针异常 */public class FileDemo06 &#123; public static void main(String[] args) &#123; show01(); //show02(); &#125; private static void show02() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode&quot;); File[] files = f1.listFiles(); for (File fileList : files) &#123; System.out.println(fileList);/* C:\\Users\\MaLin\\Desktop\\JavaCode\\.idea C:\\Users\\MaLin\\Desktop\\JavaCode\\1.txt C:\\Users\\MaLin\\Desktop\\JavaCode\\JavaCode.iml C:\\Users\\MaLin\\Desktop\\JavaCode\\out C:\\Users\\MaLin\\Desktop\\JavaCode\\src C:\\Users\\MaLin\\Desktop\\JavaCode\\背景图片1.jpg C:\\Users\\MaLin\\Desktop\\JavaCode\\背景图片2.jpg C:\\Users\\MaLin\\Desktop\\JavaCode\\背景图片3.jpg */ &#125; &#125; private static void show01() &#123; File f1 = new File(&quot;C:\\\\Users\\\\MaLin\\\\Desktop\\\\JavaCode&quot;); String[] fl1 = f1.list(); for (String fileList: fl1 ) &#123; System.out.println(fileList);/* .idea 1.txt JavaCode.iml out src 背景图片1.jpg 背景图片2.jpg 背景图片3.jpg */ &#125; &#125; &#125; 包装类概念基本数据类型的数据，使用起来很方便，但是没有对用的方法来操作这些数据，我们可以使用一个类，把基本数据类型包装起来，这个类叫包装类 在包装类中，我们可以定义一些方法来操作基本数据类型的数据 例如Integer类、Double类。。。位于Java.lang包下 基本数据类型 对应的包装类 byte Byte short Short int Interger long Long float Float double Double char Character boolean Boolean 装箱与拆箱装箱：把基本数据类型的数据，包装到包装类中 构造方法 1Integer (int value)//构造一个新分配的Integer对象，它表示指定的int值 12Integer (String s)//构造一个新分配的Integer对象，它表示String参数所指示的int值 //传递的字符串必须是基本类型的字符串，否则会抛出异常 &quot;100&quot;正确 &quot;a&quot;抛出异常 静态方法 1static Integer valueOf(int i)//返回一个表示指定的int值的Interger实例 1static Integer valueOf(String s)//返回保存指定的String的值的Integer对象 拆箱：取出包装类中的基本数据类型的数据 成员方法 1int intValue()//以int类型返回该Integer的值 示例 1234567891011121314151617181920212223242526package integer;public class IntegerDemo01 &#123; public static void main(String[] args) &#123; //装箱 //构造方法 Integer in1 = new Integer(1);//该方法已经过时了 System.out.println(in1);//1 重写了toString方法 Integer in2 = new Integer(&quot;1&quot;); System.out.println(in2);//1 //静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); Integer in4 = Integer.valueOf(&quot;1&quot;); //Integer in4 = Integer.valueOf(&quot;a&quot;);//Exception in thread &quot;main&quot; java.lang.NumberFormatException 数字格式化异常 System.out.println(in4); //拆箱 int i = in1.intValue(); System.out.println(i);//1 &#125;&#125; 自动装箱与自动拆箱​ 基本数据类型和包装类之间可以自动的相互转换（JDK1.5以后） 自动装箱 直接把int类型的整数包装起来 1Integer in1 = 1;//相当与Integer in1 = new Integer(1); 自动拆箱 如上面的in1是包装类，无法直接参与运算，可以自动转换为基本数据类型的数据在参与计算 12345/*in + 2;相当于in.intValue() + 2;自动拆箱in = in + 2;相当于in = new Integer(3);自动装箱*/in1 = in1 + 2 ArrayList集合无法直接存储整数，可以存储包装类 123ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);int i = list.get(0); 完整代码 1234567891011121314151617181920package integer;import java.util.ArrayList;public class IntegerDemo02 &#123; public static void main(String[] args) &#123; //自动装箱 Integer in1 = 1; //自动拆箱 in1 = in1 + 2; System.out.println(in1);//3 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1);//自动装箱，相当于list.add(new Integer(1)); //Integer integer = list.get(0);返回的是包装类Integer int i = list.get(0);//自动拆箱，相当于list.get(0).intValue(); System.out.println(i); &#125;&#125; 基本数据类型与字符串相互转换基本类型转为String 基本数据类型的值+”” 1String s = 100 + &quot;&quot;; 使用包装类中的静态方法 1static String toString(int i)//返回指定int类型数据的String对象 使用String类中的静态方法 1static String valueOf(int i)//返回int类型的数据 String转为对应的基本类型 使用包装类的静态方法parseXX(“字符串”) 123static int parseInt(String s);static double parseDouble(String s);... 注： 字符串的形式必须为基本类型（char类型除外）否则会报java.lang.NumberFormatException数字格式化异常 1int i = Integer.parseInt(&quot;a&quot;);//java.lang.NumberFormatException 数字格式化异常 完整代码 123456789101112131415161718192021222324252627package integer;public class IntegerDemo03 &#123; public static void main(String[] args) &#123; //基本数据类型——&gt;String //基本数据类型的值+&quot;&quot; String s1 = 100 + &quot;&quot;; System.out.println(s1 + 100);//100100 //使用包装类的静态方法 String s2 = Integer.toString(100); System.out.println(s2 + 100);//100100 //使用String类的valueOf方法 String s3 = String.valueOf(100); System.out.println(s3 + 100);//100100 //字符串--&gt;基本数据类型 //包装类的parseXX(&quot;s&quot;)方法 int i = Integer.parseInt(&quot;100&quot;); System.out.println(i + 100);//200 //int i2 = Integer.parseInt(&quot;a&quot;);//java.lang.NumberFormatException 数字格式化异常 &#125;&#125; Date概述java.util.Date:表示日期、时间的类，精确到毫秒 毫秒值1000毫秒 = 1秒 可以用于时间和日期的计算 把日期转换为毫秒进行计算 12345678910111213141516package date;/*时间原点19700101 00:00:00 (英国格林威治)19700101 08:00:00 (中国 东八区时间+8h) */public class DateDemo01 &#123; public static void main(String[] args) &#123; //获取当前系统时间到时间原点一共经历了多少毫秒 System.out.println(System.currentTimeMillis()); &#125;&#125; 把毫秒转换为日期 构造方法示例 123456789101112131415161718192021222324package date;import java.util.Date;public class DateDemo02 &#123; public static void main(String[] args) &#123; dateDemo01();//Thu May 13 15:44:39 CST 2021 dateDemo02(0L);//Thu Jan 01 08:00:00 CST 1970 &#125; private static void dateDemo01() &#123; Date date = new Date(); System.out.println(date);//直接打印调用的是date对象的toString方法，它重写了toString方法 &#125; private static void dateDemo02(Long l) &#123; Date date = new Date(l); System.out.println(date); &#125;&#125; 成员方法示例 12345678910111213141516package date;import java.util.Date;public class DateDemo03 &#123; public static void main(String[] args) &#123; dataDemo03(); &#125; private static void dataDemo03() &#123; Date date = new Date(); long time = date.getTime();//该成员方法返回的是一个long类型的数值 到时间原点有多少毫秒 System.out.println(time); &#125;&#125; DateFormat类java.text.DataFormat：时间日期的格式化子类的抽象类 作用： 格式化（日期–&gt;文本） 解析（文本–&gt;日期） 成员方法： 1SimpleDateFormat(String pattern) //用于给定的模式和默认语言环境的日期格式符号构造 参数：String pattern用于指定模式 模式：区分大小写 例如： 12//&quot;yyyy-MM-dd HH:mm:ss&quot;//&quot;yyyy年MM月dd日 HH时mm分ss秒&quot; 注： 模式中的字母不能改，连接模式的符号可以改变。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDataFormatDemo01 &#123; public static void main(String[] args) throws ParseException &#123; sdf1(); sdf2(); &#125; /* 使用DateFormat中的format方法把日期转换为文本 1.创建SimpleDataFormat对象并指定对应模式 2.调用对象的format(date)方法把传进来的date日期格式化为指定模式的文本 */ private static void sdf1() &#123; //1.创建SimpleDataFormat对象并指定对应模式 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); //2.调用对象的format(date)方法把传进来的date日期格式化为指定模式的文本 Date date = new Date(); String text = sdf.format(date); System.out.println(date);//Thu May 13 18:13:14 CST 2021 System.out.println(text);//2021年05月13日 18时13分14秒 &#125; /* 使用DataFormat中的parse方法把文本转换为日期 1.创建SimpleDataFormat对象并指定对应模式 2.调用对象的format(date)方法把传进来的date日期格式化为指定模式的文本 注： public Date parse(String source) throws ParseException parse方法声明了一个异常ParseException解析异常 如果字符串和构造方法中的模式不一样，就会抛出此异常 调用一个抛出异常的方法就必须处理这个异常 1.throws继续抛出异常 2.try...catch这个异常 */ private static void sdf2() throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); Date date = sdf.parse(&quot;2021年05月13日 18时13分14秒&quot;); System.out.println(date); &#125;&#125; 练习计算一个人活了多少天 Scanner获取这个人指定模式的出生日期，计算其对应的毫秒值 获取当前时间的毫秒值 两个毫秒值相减，把计算结果转换为天 123456789101112131415161718192021222324252627282930313233343536package date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;/*计算一个人活了多少天1. Scanner获取这个人指定模式的出生日期，计算其对应的毫秒值2. 获取当前时间的毫秒值3. 两个毫秒值相减，把计算结果转换为天 */public class Demo01 &#123; public static void main(String[] args) throws ParseException &#123; //新建Scanner对象用于获取用户输入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的出生日期，格式为yyyy-MM-dd&quot;); //把用户输入的日期转换为毫秒值 String birthDate = sc.next(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf.parse(birthDate); //拿到两个毫秒值 long time1 = date.getTime(); long time2 = new Date().getTime(); //毫秒转换为日 System.out.println((time2-time1)/1000/60/60/24); sc.close(); &#125;&#125; Systemjava.lang.System类提供了大量的静态方法，可以获取与系统相关的信息或系统级操作 常用方法 public static long currentTimeMillis()：返回以毫秒只为单位的当前时间 public static void arraycopy(Object src, int srcPocs, Object dest, int destPos, int length)：数组中指定的的数据拷贝到另一个数组中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package system;import java.util.Arrays;/*- public static long currentTimeMillis() 返回以毫秒只为单位的当前时间- public static void arraycopy(Object src, int srcPocs, Object dest, int destPos, int length) 数组中指定的的数据拷贝到另一个数组中 */public class SystemDemo01 &#123; public static void main(String[] args) &#123; //demo01(); demo02(); &#125; /* public static void arraycopy(Object src, int srcPocs, Object dest, int destPos, int length) 数组中指定的的数据拷贝到另一个数组中 参数 src - 源数组。 srcPos - 源数组中的起始位置。 dest - 目标数组。 destPos - 目标数据中的起始位置。 length - 要复制的数组元素的数量。 练习 将src数组的前三个元素复制到dest数组的元素的前三个位置 src:[1, 2, 3, 4, 5] dest:[6, 7, 8, 9, 10] 复制后 dest:[1, 2, 3, 9, 10] */ private static void demo02() &#123; int[] src = &#123;1, 2, 3, 4, 5&#125;; int[] dest = &#123;6, 7, 8, 9, 10&#125;; System.out.println(&quot;复制前：&quot; + Arrays.toString(dest));//复制前：[6, 7, 8, 9, 10] System.arraycopy(src, 0, dest, 0, 3); System.out.println(&quot;复制后：&quot; + Arrays.toString(dest));//复制后：[1, 2, 3, 9, 10] &#125; /* `public static long currentTimeMillis()`：返回以毫秒只为单位的当前时间 用来测试程序的效率 练习 用for循环打印1-999所需的毫秒值 */ private static void demo01() &#123; long s = System.currentTimeMillis(); for (int i = 1; i &lt;= 999; i++) &#123; System.out.println(i); &#125; long e = System.currentTimeMillis(); System.out.println(&quot;程序共耗时：&quot; + (e - s) + &quot;毫秒&quot;); &#125;&#125; String概述java.lang.String代表字符串，程序中的所有字符”abc”，都可以看为实现这个类的实例 使用步骤常用方法练习StringBufferjava.lang.StringBuffer 1public final class StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 构造方法 StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。StringBuffer(CharSequence seq) public java.lang.StringBuilder(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符。StringBuffer(int capacity) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。 StringBuilder 字符串缓冲区字符串缓冲区可以提高字符串的操作效率 底层也是一个数组，但是没有被final修饰，可以改变长度 byte[] byte = new byte[16] StringBuilder在内存中始终是一个数组，占用空间小，效率高。 如果超出StringBuilder的容量，他会自动扩容 构造方法 public StringBuilder()：构造一个空的StringBuilder容器 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去 1234567891011121314151617package stringbuilder;/*java.lang.StringBuilder 字符串缓冲区可以提高字符串的操作效率构造方法 public StringBuilder()：构造一个空的StringBuilder容器 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去 */public class StringBuilderDemo01 &#123; public static void main(String[] args) &#123; StringBuilder stringBuilder1 = new StringBuilder(); System.out.println(&quot;sbu1:&quot; + stringBuilder1); StringBuilder stringBuilder2 = new StringBuilder(&quot;abc&quot;); System.out.println(&quot;sbu2:&quot; + stringBuilder2); &#125;&#125; 成员方法 public StringBuilder append(...)：添加任意类型的数据的字符串形式，并返回当前对象本身 public String toString()：将StringBuilder对象转换为String对象 12345678910111213141516171819202122232425262728package stringbuilder;import java.util.Locale;/*- public StringBuilder append(...)：添加任意类型的数据的字符串形式，并返回当前对象本身- public String toString()：将StringBuilder对象转换为String对象 */public class StringBuilderDemo02 &#123; public static void main(String[] args) &#123; StringBuilder sbu1 = new StringBuilder(); /* sbu1.append(&quot;abc&quot;); sbu1.append(true); sbu1.append(1); sbu1.append(&#x27;a&#x27;); System.out.println(sbu1);*/ /* 链式编程:方法的返回值就是对象，可以根据对象继续调用方法 */ System.out.println(&quot;abc&quot;.toUpperCase());//ABC 转换为大写字母 sbu1.append(&quot;abc&quot;).append(true).append(1).append(&#x27;a&#x27;); System.out.println(sbu1); &#125;&#125; 1234567891011package stringbuilder;public class StringBuilderDemo03 &#123; public static void main(String[] args) &#123; //StringBuilder---&gt;String StringBuilder stringBuilder = new StringBuilder(&quot;hello&quot;); String s1 = stringBuilder.toString(); System.out.println(s1); &#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"网络编程","slug":"网络编程","date":"2021-05-12T10:23:30.000Z","updated":"2021-05-16T08:15:19.854Z","comments":true,"path":"2021/05/12/网络编程/","link":"","permalink":"http://example.com/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"网络编程1.1概述 地球村","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"GUI编程之贪吃蛇","slug":"GUI编程之贪吃蛇","date":"2021-05-11T16:34:11.000Z","updated":"2021-05-13T13:32:23.428Z","comments":true,"path":"2021/05/12/GUI编程之贪吃蛇/","link":"","permalink":"http://example.com/2021/05/12/GUI%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B4%AA%E5%90%83%E8%9B%87/","excerpt":"","text":"贪吃蛇小游戏素材下载提取码7777 代码 1234567891011121314151617181920package cn.linsip.snake;import javax.swing.*;//游戏主程序public class StartGame &#123; public static void main(String[] args) &#123; //实例JFrame JFrame jFrame = new JFrame(); //设置属性 jFrame.setBounds(0,0,900,720); jFrame.setResizable(false); jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //把GamePanel加进来 jFrame.add(new GamePanel()); //设置可见性 jFrame.setVisible(true); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package cn.linsip.snake;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.util.Random;//游戏面板public class GamePanel extends JPanel implements KeyListener, ActionListener &#123; //定义蛇的数据结构 脑袋+身体+节数 int length; int[] snakeX = new int[500]; int[] snakeY = new int[500]; //蛇移动方向 String fx; //食物 int foodx; int foody; Random random = new Random(); //游戏的暂停与开始 boolean flag; //游戏失败判定 boolean isfail; //分数 int score; Timer timer = new Timer(200, this); //构造器 public GamePanel() &#123; init();//初始化 //获得焦点和键盘事件 setFocusable(true); addKeyListener(this); timer.start(); &#125; //初始化方法 public void init() &#123; length = 3; snakeX[0] = 100; snakeY[0] = 100;//蛇头 snakeX[1] = 75; snakeY[1] = 100;//蛇身 snakeX[2] = 50; snakeY[2] = 100;//蛇身 fx = &quot;R&quot;; flag = false; isfail = false; score = 0; foodx = 25+ 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); &#125; //绘制面板 游戏中的所有东西都是由Graphics这个画笔画的 @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g);//清屏 setBackground(Color.white);//定义面板背景颜色 Data.header.paintIcon(this, g, 25, 11);//绘制头部广告位 g.fillRect(25, 75, 850, 600);//绘制长方形，游戏的主界面 //画分数 g.setColor(Color.YELLOW); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD,15)); g.drawString(&quot;当前分数为：&quot; + score, 750, 35); //画食物 Data.food.paintIcon(this, g, foodx, foody); //画蛇头 if (fx.equals(&quot;R&quot;)) &#123; Data.right.paintIcon(this, g, snakeX[0], snakeY[0]); &#125; else if (fx.equals(&quot;L&quot;)) &#123; Data.left.paintIcon(this, g, snakeX[0], snakeY[0]); &#125; else if (fx.equals(&quot;U&quot;)) &#123; Data.up.paintIcon(this, g, snakeX[0], snakeY[0]); &#125; else if (fx.equals(&quot;D&quot;)) &#123; Data.down.paintIcon(this, g, snakeX[0], snakeY[0]); &#125; //画蛇身 for (int i = 1; i &lt; length; i++) &#123; Data.body.paintIcon(this, g, snakeX[i], snakeY[i]); &#125; //画开始与暂停游戏 if (flag == false) &#123; g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 40)); g.drawString(&quot;请按空格开始游戏&quot;, 300, 400); &#125; //画游戏结束 if (isfail) &#123; g.setColor(Color.RED); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 40)); g.drawString(&quot;GAME OVER&quot;, 350, 350); &#125; &#125; @Override public void keyTyped(KeyEvent e) &#123; &#125; //重写键盘按压事件 @Override public void keyPressed(KeyEvent e) &#123; int keyCode = e.getKeyCode(); if (isfail) &#123; flag = false; if (keyCode == KeyEvent.VK_SPACE) &#123; init(); &#125; &#125; if (keyCode == KeyEvent.VK_SPACE) &#123; flag = !flag; repaint(); &#125; //蛇的移动 if (keyCode == KeyEvent.VK_UP) &#123; fx = &quot;U&quot;; &#125; else if (keyCode == KeyEvent.VK_DOWN) &#123; fx = &quot;D&quot;; &#125; else if (keyCode == KeyEvent.VK_LEFT) &#123; fx = &quot;L&quot;; &#125; else if (keyCode == KeyEvent.VK_RIGHT) &#123; fx = &quot;R&quot;; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; //事件监听 通过固定事件来刷新 1s=10次 @Override public void actionPerformed(ActionEvent e) &#123; if (flag) &#123; //身体移动 for (int i = length - 1; i &gt; 0; i--) &#123; snakeX[i] = snakeX[i - 1]; snakeY[i] = snakeY[i - 1]; &#125; //脑袋走向 if (fx.equals(&quot;R&quot;)) &#123; //头右移 snakeX[0] = snakeX[0] + 25; //边界判断 if (snakeX[0] &gt; 850) &#123; snakeX[0] = 25; &#125; &#125; else if (fx.equals(&quot;L&quot;)) &#123; //头左移 snakeX[0] = snakeX[0] - 25; //边界判断 if (snakeX[0] &lt; 25) &#123; snakeX[0] = 850; &#125; &#125; else if (fx.equals(&quot;U&quot;)) &#123; //头上移 snakeY[0] = snakeY[0] - 25; //边界判断 if (snakeY[0] &lt; 75) &#123; snakeY[0] = 650; &#125; &#125; else if (fx.equals(&quot;D&quot;)) &#123; //头左移 snakeY[0] = snakeY[0] + 25; //边界判断 if (snakeY[0] &gt; 650) &#123; snakeY[0] = 75; &#125; &#125; //吃食物判断 if (foodx == snakeX[0] &amp;&amp; foody == snakeY[0]) &#123; length++; score += 10; foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); &#125; //失败判定 for (int i = length - 1; i &gt; 0; i--) &#123; if (snakeX[0] == snakeX[i] &amp;&amp; snakeY[0] == snakeY[i]) &#123; isfail = true; flag = false; &#125; &#125; repaint(); &#125; //启动计时器 timer.start(); &#125;&#125; 12345678910111213141516171819202122232425package cn.linsip.snake;import javax.swing.*;import java.net.URL;//数据中心//用于存放图片相关数据public class Data &#123; //绝对路径 相对路径 public static URL headerUrl = Data.class.getResource(&quot;/statics/header.png&quot;); public static ImageIcon header = new ImageIcon(headerUrl); public static URL bodyUrl = Data.class.getResource(&quot;/statics/body.png&quot;); public static ImageIcon body = new ImageIcon(bodyUrl); public static URL downUrl = Data.class.getResource(&quot;/statics/down.png&quot;); public static ImageIcon down = new ImageIcon(downUrl); public static URL foodUrl = Data.class.getResource(&quot;/statics/food.png&quot;); public static ImageIcon food = new ImageIcon(foodUrl); public static URL leftUrl = Data.class.getResource(&quot;/statics/left.png&quot;); public static ImageIcon left = new ImageIcon(leftUrl); public static URL rightUrl = Data.class.getResource(&quot;/statics/right.png&quot;); public static ImageIcon right = new ImageIcon(rightUrl); public static URL upUrl = Data.class.getResource(&quot;/statics/up.png&quot;); public static ImageIcon up = new ImageIcon(upUrl);&#125; 游戏截图","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Gitee+PicGo免费私人图床搭建教程","slug":"Gitee-PicGo免费私人图床搭建教程","date":"2021-05-11T12:18:26.000Z","updated":"2021-05-11T18:50:57.436Z","comments":true,"path":"2021/05/11/Gitee-PicGo免费私人图床搭建教程/","link":"","permalink":"http://example.com/2021/05/11/Gitee-PicGo%E5%85%8D%E8%B4%B9%E7%A7%81%E4%BA%BA%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"Gitee+PicGo免费私人图床搭建教程我们在写Markdown博客的时候，上传到网上后，图片仍然保存在本地并不会上传。 解决方法 自己搭建免费图床 用收费图床 前期准备 注册Gitee账号 Gitee官网 新建仓库 生成私人令牌 打开账号设置，私人令牌，生成令牌 勾选下面几项，描述自己随便写，然后提交 保存好你的私人令牌 下载安装PicGo PicGo下载 自行安装 Node.js Node.js 检验是否安装成功 命令行输入 1node --version 如果看到版本号就安装成功 PicGo配置PicGo下载安装一个gitee-uploader插件 打开图床设置，填入右边方框内容 其中： repo 比如你的 gitee 账号为 user，存储图片的仓库为 images，则此处填入 user/images branch 分支 token 私人令牌 path 路径 使用Typera 打开Typera，按ctrl+.进入偏好设置，点击图像 对插入图片做以下设置 上传服务选择PicGo，路径选择自己安装的PicGo路径 点击验证图片上传选项，弹出如下内容表示配置成功 在Typera插入图片时就会自动上传，而不用保存在本地","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"OOP原则","slug":"OOP原则","date":"2021-05-11T07:33:58.000Z","updated":"2021-05-11T16:49:21.651Z","comments":true,"path":"2021/05/11/OOP原则/","link":"","permalink":"http://example.com/2021/05/11/OOP%E5%8E%9F%E5%88%99/","excerpt":"","text":"OOP原则OOP概述 面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。 什么是优秀的代码？ 代码可读性高 逻辑清晰 高内聚，低耦合 ··· OOP三大特性 封装 继承 多态 OOP五大设计原则单一职责原则 开闭原则 里氏替换原则 接口隔离原则 依赖倒置原则 总结高内聚，低耦合","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"GUI图形用户界面","slug":"GUI","date":"2021-05-06T14:21:24.000Z","updated":"2021-05-11T12:05:49.121Z","comments":true,"path":"2021/05/06/GUI/","link":"","permalink":"http://example.com/2021/05/06/GUI/","excerpt":"","text":"GUIGUI全称Graphical User Interface，图形用户界面 组件 窗口 弹窗 面板 文本框 列表框 按钮 图片 监听事件 鼠标 键盘事件 简介GUI核心技术：AWT、SWing 为什么不火 界面不美观 需要jre环境 为什么要学习GUI MVC，了解监听器 可以写出自己心中想要的工具 工作中可能维护到SWing界面 AWTAWT介绍AWT(Abstract Windows Toolkit)抽象窗口工具 包含很多类和接口 元素：窗口、按钮、文本框 Java.awt包的层次结构如下 组件和容器Component and Container容器 容器(Container)也是一个类，实际上是Component的子类，因此容器本身也是一个组件，具有组件的所有性质，但是它的主要功能是容纳其它组件和容器。容器可以简化图形化界面的设计，以整体结构来布置界面。所有的容器都可以通过add()方法向容器中添加组件。常用的容器3种：Panel, Frame, Applet。 来源：百度百科 框架Frame 构造方法： 1Frame frame = new Frame(&quot;&quot;); 要生成一个窗口，通常使用Window的子类Frame类进行实例化，而不是直接使用Window 类，框架的外观就像平常Windows系统下的窗口，有标题、边框、菜单和大小等。setSize()方法可以设置框架尺寸的大小，setVisibe()方法可以设置窗口的可见性。 来源：百度百科 示例： 12345678910111213141516171819202122package cn.linsip.lesson01;import java.awt.*;//第一个图形界面public class TestFrame &#123; public static void main(String[] args) &#123; //Frame 看源码 Frame frame = new Frame(&quot;我的第一个Java图形界面&quot;); //设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400, 400); //设置背景颜色 frame.setBackground(new Color(1, 1, 1)); //设置弹出的初始位置 frame.setLocation(0, 0); //设置大小固定 frame.setResizable(false); &#125;&#125; 窗口出现问题 窗口关闭不掉 解决方法：停止Java程序运行 回顾封装： 1234567891011121314151617181920212223242526272829package cn.linsip.lesson01;import java.awt.*;//封装TestFramepublic class TestFrame02 &#123; public static void main(String[] args) &#123; //开启多个窗口 MyFrame myFrame1 = new MyFrame(200, 200, 200, 200); MyFrame myFrame2 = new MyFrame(400, 200, 200, 200); MyFrame myFrame3 = new MyFrame(200, 400, 200, 200); MyFrame myFrame4 = new MyFrame(400, 400, 200, 200); &#125;&#125;//自定义类来继承Frame实现封装class MyFrame extends Frame &#123; //定义静态变量，用于区别多个窗口 static int id; public MyFrame(int x, int y, int w, int h) &#123; //调用父类即Frame super(&quot;MyFrame&quot; + (++id)); //设置参数 setVisible(true); setBackground(Color.black); setBounds(x, y, w, h); setResizable(false); &#125;&#125; 面板panel 框架一般用作Java应用程序的窗口，而Applet是Java小程序的窗口。与Frame不同，Applet是在网页中显示的，也可以通过添加Panel进行组件布局。 来源：百度百科 Panel一个空间，非独立存在 可以在panel中添加文本框、文本域、列表、单选按钮、复选按钮、画布、标签、字体大小、事件、滚动条 构造方法 1Panel panel = new Panel(); 示例 12345678910111213141516171819202122232425262728293031package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;//Panelpublic class TestPanel &#123; public static void main(String[] args) &#123; Frame frame = new MyFrame(100, 100, 400, 400, Color.RED); Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 panel.setBounds(100, 100, 200, 200);//Panel的坐标是相对于Frame的 panel.setBackground(Color.white); //panel加入frame frame.add(panel); //窗口监听WindowListener，实现关闭窗口功能,监听器参数是一个内部类WindowAdapter //适配器模式 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 布局管理器 布局管理器（LayoutManager）：每个容器都有一个布局管理器，当容器需要对某个组件进行定位或判断其大小、尺寸时，就会调用其对应的布局管理器。使用布局管理器可以实现跨平台的特性，并且获得动态的布局效果。布局管理器负责管理组件的排列顺序、大小和位置。不同的布局管理器使用不同的布局策略，容器可以通过选择不同的布局管理器来决定如何布局。 来源：百度百科 流式布局Flowlayout FlowLayout是Panel 和 Applet 的默认布局管理器。在该布局管理器中，组件在容器中按照从上到下，从左到右的顺序进行排列，行满后则换行。 构造方法 123456//默认构造方法，设置居中对齐方式，横向和纵向间隔均为默认5像素FlowLayout();//设置居左对齐，横向和纵向间隔均为默认5像素FlowLayout(new FlowLayout.LEFT);//设置居右对齐，横向间隔20像素，纵向间隔20像FlowLayout(new FlowLayout.RIGHT, 20, 20); 示例 12345678910111213141516171819202122package cn.linsip.lesson01;import java.awt.*;public class TestFlowLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); //组件按钮 Button button1 = new Button(&quot;button1&quot;); Button button2 = new Button(&quot;button2&quot;); Button button3 = new Button(&quot;button3&quot;); //设置流式布局 frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setVisible(true); frame.setBounds(100,100,200,200); //添加Buttun到Frame frame.add(button1); frame.add(button2); frame.add(button3); &#125;&#125; 边界布局管理器BorderLayout BorderLayout是Window、Frame和Dialog的默认布局管理器，其将容器分成North、South、East、West和Center 5个区域，每个区域只能放置一个组件。在使用add()方法添加组件到容器时，必须指定将其放置在哪个区域中。使用BorderLayout时，如果容器大小发生变换，组件的相对位置不变。 来源：百度百科 构造方法 1BorderLayout bl = new BorderLayout(); 示例 12345678910111213141516171819202122232425262728package cn.linsip.lesson01;import java.awt.*;public class TestBorderTest &#123; public static void main(String[] args) &#123; //一个Frame Frame frame = new Frame(); //四个按钮 Button east = new Button(&quot;EAST&quot;); Button west = new Button(&quot;WEST&quot;); Button south = new Button(&quot;SOUTH&quot;); Button north = new Button(&quot;NORTH&quot;); Button center = new Button(&quot;CENTER&quot;); //按钮添加到frame frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); //设置frame属性 frame.setVisible(true); frame.setBounds(100,100,200,200); &#125;&#125; 网格布局管理器GridLayout GridLayout 可使容器中的各个组件呈网格状布局，平局占据容器的空间，即使容器的大小发生变化，每个组件还是平均占据容器的空间。和FlowLayout一样，GridLayout也是按照从上到下，从左到右的规律进行排列的。 来源：百度百科 构造方法 1GridLayout = new GridLayout(); 示例 12345678910111213141516171819202122232425262728293031323334package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestGridLayout &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setVisible(true); Button button1 = new Button(&quot;butten1&quot;); Button button2 = new Button(&quot;button2&quot;); Button button3 = new Button(&quot;button3&quot;); Button button4 = new Button(&quot;button4&quot;); Button button5 = new Button(&quot;button5&quot;); Button button6 = new Button(&quot;button6&quot;); frame.setLayout(new GridLayout(3,2)); //frame.setBounds(100,100,200,200); frame.add(button1); frame.add(button2); frame.add(button3); frame.add(button4); frame.add(button5); frame.add(button6); frame.pack();//Java函数，自动匹配大小 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 练习 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.linsip.lesson01;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class FrameDemo &#123; public static void main(String[] args) &#123; Frame frame = new Frame(&quot;练习&quot;); Panel panel1 = new Panel(new BorderLayout()); Panel panel2 = new Panel(new GridLayout(2, 1)); Panel panel3 = new Panel(new BorderLayout()); Panel panel4 = new Panel(new GridLayout(2, 2)); frame.setLayout(new GridLayout(2, 1)); frame.setSize(400, 400); frame.setVisible(true); panel1.add(new Button(&quot;east&quot;), BorderLayout.EAST); panel1.add(new Button(&quot;west&quot;), BorderLayout.WEST); panel2.add(new Button(&quot;p2-1&quot;)); panel2.add(new Button(&quot;p2-2&quot;)); panel1.add(panel2, BorderLayout.CENTER); frame.add(panel1); panel3.add(new Button(&quot;east&quot;), BorderLayout.EAST); panel3.add(new Button(&quot;west&quot;), BorderLayout.WEST); panel4.add(new Button(&quot;p4-1&quot;)); panel4.add(new Button(&quot;p4-2&quot;)); panel4.add(new Button(&quot;p4-3&quot;)); panel4.add(new Button(&quot;p4-4&quot;)); panel3.add(panel4, BorderLayout.CENTER); frame.add(panel3); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125; 总结： Frame是一个顶级窗口 Panel无法单独显示，必须添加其到某个容器中 掌握3种布局管理器 Frame设置大小、定位、背景颜色、可见性、监听。 事件监听 Java事件监听器是由事件类和监听接口组成，自定义一个事件前，必须提供一个事件的监听接口以及一个事件类。JAVA中监听接口是继承java.util.EventListener的类，事件类继承java.util.EventObject的类。 来源：百度百科 事件发生的时候，该干什么 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestActionEvent01 &#123; public static void main(String[] args) &#123; //按下按钮，触发事件 Frame frame = new Frame(); Button button = new Button(&quot;say hello&quot;); //给按钮添加一个事件监听，ActionListener是一个接口，需要一个ActionListener参数，我们自定义一个类来实现这个接口 MyActionListener myActionListener = new MyActionListener(); //按钮添加监听 button.addActionListener(myActionListener); //按钮加入frame frame.add(button, BorderLayout.CENTER); //设置窗口属性 frame.pack(); frame.setVisible(true); //我们这里重写以下关闭窗口的方法 windowClosing(frame); &#125; //关闭窗口的方法 private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;//自定义类来实现接口ActionListenerclass MyActionListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 两个按钮共用一个事件 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestActionEvent02 &#123; public static void main(String[] args) &#123; //俩按钮实现一个事件 Frame frame = new Frame(); Button button1 = new Button(&quot;start&quot;); Button button2 = new Button(&quot;stop&quot;); //自定义类来实现事件监听 MyMonitor myActionListener = new MyMonitor(); //按钮添加监听 button1.addActionListener(myActionListener); button2.addActionListener(myActionListener); //frame添加button frame.add(button1, BorderLayout.NORTH); frame.add(button2, BorderLayout.SOUTH); //frame属性 frame.pack(); frame.setVisible(true); windowClosing(frame); &#125; private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;class MyMonitor implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;按钮getCommand:&quot; + e.getActionCommand()); &#125;&#125; 注： 优先用setActionCommand()，其次才是Button的标签 1button1.setActionCommand(&quot;s&quot;); 输入框监听TextField12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.linsip.lesson02;import cn.linsip.lesson01.TestFrame;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestText &#123; public static void main(String[] args) &#123; //启动 new MyFrame(); &#125;&#125;//我们用自定义类来封装Frameclass MyFrame extends Frame &#123; public MyFrame() &#123; //添加文本框 TextField textField = new TextField(); add(textField); //监听文本框输入的文字 MyMonitor2 myMonitor2 = new MyMonitor2(); textField.addActionListener(myMonitor2); //设置替换编码 //textField.setEchoChar(&#x27;*&#x27;); //设置大小，可见性等等 pack(); setVisible(true); window &#125; private static void windowClosing(Frame frame) &#123; frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); &#125;&#125;class MyMonitor2 implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; TextField testField = (TextField) e.getSource();//事件获得的资源返回的是一个对象，强转为文本域 System.out.println(testField.getText());//获得文本框内容并打印 testField.setText(&quot;&quot;);//设置文本框内容为空 &#125;&#125; 简易的计算器，组合+内部类回归复习 OOP原则：组合，大于继承 组合 1234567public class A extends B&#123; &#125;public class A&#123; private B b;&#125; 练习 加法计算器 如图 思路： 根据拿到前两个数值，返回第三个数值 如何拿到前两个数值 如何返回第三个数值 进一步优化代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;//main函数用于启动或者测试程序public class TestCalc &#123; public static void main(String[] args) &#123; Calc calc = new Calc(); &#125;&#125;//自定义一个计算器类class Calc extends Frame &#123; public Calc() &#123; //3个文本框 TextField text1 = new TextField(20); TextField text2 = new TextField(20); TextField text3 = new TextField(20); //一个按钮+事件 Button button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor3(text1, text2, text3)); //一个标签 Label label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125;&#125;//自定义一个监听器class MyMonitor3 implements ActionListener &#123; //构造方法拿到这三个值 private TextField text1, text2, text3; public MyMonitor3(TextField text1, TextField text2, TextField text3) &#123; this.text1 = text1; this.text2 = text2; this.text3 = text3; &#125; @Override public void actionPerformed(ActionEvent e) &#123; //按下按钮事件e，1获取前两个文本框内容， int num1 = Integer.parseInt(text1.getText()); int num2 = Integer.parseInt(text2.getText()); //2计算返回值到第三个文本框 text3.setText(&quot;&quot; + (num1 + num2)); //,3清除前两个框 text1.setText(&quot;&quot;); text2.setText(&quot;&quot;); &#125;&#125; 完全面向对象的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestCalc2 &#123; public static void main(String[] args) &#123; new Calc2().loadCalc(); &#125;&#125;class Calc2 extends Frame &#123; TextField text1, text2, text3; Button button; Label label; public void loadCalc() &#123; //3个文本框 text1 = new TextField(20); text2 = new TextField(20); text3 = new TextField(20); //一个按钮+事件 button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor4(this)); //一个标签 label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125;&#125;class MyMonitor4 implements ActionListener &#123; //构造方法拿到这个对象 private Calc2 calc2 = null; public MyMonitor4(Calc2 calc2) &#123; this.calc2 = calc2; &#125; @Override public void actionPerformed(ActionEvent e) &#123; //1获取前两个文本框内容， //2计算返回值到第三个文本框 //3清除前两个框 int num1 = Integer.parseInt(calc2.text1.getText()); int num2 = Integer.parseInt(calc2.text2.getText()); calc2.text3.setText(&quot;&quot; + (num1 + num2)); calc2.text1.setText(&quot;&quot;); calc2.text2.setText(&quot;&quot;); &#125;&#125; 内部类写法 内部类可以直接访问外部类的属性和方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.linsip.lesson02;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestCalc2 &#123; public static void main(String[] args) &#123; new Calc2().loadCalc(); &#125;&#125;class Calc2 extends Frame &#123; TextField text1, text2, text3; Button button; Label label; public void loadCalc() &#123; //3个文本框 text1 = new TextField(20); text2 = new TextField(20); text3 = new TextField(20); //一个按钮+事件 button = new Button(&quot;=&quot;); button.addActionListener(new MyMonitor4()); //一个标签 label = new Label(&quot;+&quot;); //Flowlayout布局, setLayout(new FlowLayout()); add(text1); add(label); add(text2); add(button); add(text3); pack(); setVisible(true); &#125; //内部类 private class MyMonitor4 implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; //1获取前两个文本框内容， //2计算返回值到第三个文本框 //3清除前两个框 int num1 = Integer.parseInt(calc2.text1.getText()); int num2 = Integer.parseInt(calc2.text2.getText()); calc2.text3.setText(&quot;&quot; + (num1 + num2)); calc2.text1.setText(&quot;&quot;); calc2.text2.setText(&quot;&quot;); &#125;&#125;&#125; 画笔12345678910111213141516171819202122232425package cn.linsip.lesson03;import java.awt.*;public class TestPaint &#123; public static void main(String[] args) &#123; new Paint().loadFrame(); &#125;&#125;class Paint extends Frame &#123; public void loadFrame() &#123; setBounds(200, 200, 400, 400); setVisible(true); &#125; @Override public void paint(Graphics g) &#123; //g.setColor(Color.ORANGE); g.drawOval(100, 100, 200, 200); g.fillOval(100, 100, 200, 200); //还原画笔默认颜色 &#125;&#125; 鼠标监听目的：想要实现鼠标画画 思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.linsip.lesson03;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.util.ArrayList;import java.util.Iterator;/*鼠标监听事件 */public class TestMouseListener &#123; public static void main(String[] args) &#123; new Myframe(&quot;画图&quot;); &#125;&#125;class Myframe extends Frame &#123; private ArrayList points; //画画需要画笔，需要监听鼠标位置，需要用集合存储 public Myframe(String title) &#123; super(title); setBounds(100, 100, 400, 400); //存鼠标点击的位置 points = new ArrayList&lt;&gt;(); setVisible(true); //鼠标监听器针对这个窗口 addMouseListener(new MyMouseListener()); &#125; @Override public void paint(Graphics g) &#123; //画画,监听鼠标的事件 Iterator iterator = points.iterator(); while (iterator.hasNext()) &#123; Point point = (Point) iterator.next(); g.setColor(Color.BLUE); g.fillOval(point.x, point.y, 10, 10); &#125; &#125; //添加这个点到界面上 public void addPoint(Point point) &#123; points.add(point); &#125; //适配器模式 private class MyMouseListener extends MouseAdapter &#123; //鼠标 按下 弹起 按住不放 @Override public void mousePressed(MouseEvent e) &#123; Myframe myframe = (Myframe) e.getSource(); //我们点击的时候就会产生一个点 //这个点就是鼠标点击的点 myframe.addPoint(new Point(e.getX(), e.getY())); //每次点击鼠标都要重画一次 myframe.repaint(); &#125; &#125;&#125; 窗口监听12345678910111213141516171819202122232425262728293031323334353637package cn.linsip.lesson03;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestWindow &#123; public static void main(String[] args) &#123; new WindowFrame(); &#125;&#125;class WindowFrame extends Frame&#123; public WindowFrame()&#123; setBackground(Color.BLUE); setBounds(100,100,400,400); setVisible(true); this.addWindowListener( new WindowAdapter() &#123; //关闭窗口 @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;正在关闭&quot;); System.exit(0); &#125; //激活窗口 @Override public void windowActivated(WindowEvent e) &#123; System.out.println(&quot;已进入当前窗口&quot;); &#125; &#125; ); &#125;&#125; 键盘监听12345678910111213141516171819202122232425262728293031package cn.linsip.lesson03;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;public class TestKeyListener &#123; public static void main(String[] args) &#123; new MyFrame(); &#125;&#125;class MyFrame extends Frame&#123; public MyFrame()&#123; setBounds(0, 0,400,400); setBackground(Color.yellow); setVisible(true); this.addKeyListener(new KeyAdapter() &#123; //键盘按压 @Override public void keyPressed(KeyEvent e) &#123; //获得按压的键 int keyCode = e.getKeyCode(); System.out.println(keyCode); if (keyCode == KeyEvent.VK_UP) &#123; System.out.println(&quot;UP&quot;); &#125; &#125; &#125;); &#125;&#125; Swing窗口、面板123456789101112131415161718192021package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;public class JFrameDemo01 &#123; public void init()&#123; JFrame jFrame = new JFrame(&quot;第一个JFrame窗口&quot;); jFrame.setBounds(0,0,400,400); jFrame.setVisible(true); JLabel jLabel = new JLabel(&quot;我的第一个JFrame窗口&quot;,SwingConstants.CENTER);//建一个label放在容器中间 jFrame.add(jLabel); jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//添加窗口关闭，默认隐藏 jFrame.getContentPane().setBackground(Color.cyan); &#125; public static void main(String[] args) &#123; new JFrameDemo01().init(); &#125;&#125; 弹窗12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class DialogDemo01 extends JFrame &#123; public DialogDemo01() &#123; this.setBounds(0, 0, 200, 200); this.setVisible(true); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); Container contentPane = this.getContentPane(); contentPane.setLayout(null); JButton jButton = new JButton(&quot;弹窗&quot;); jButton.setBounds(10, 10, 80, 50); jButton.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; new MyDialog(); &#125; &#125;); contentPane.add(jButton); &#125; public static void main(String[] args) &#123; new DialogDemo01(); &#125;&#125;class MyDialog extends JDialog &#123; public MyDialog() &#123; this.setVisible(true); this.setBounds(100, 100, 200, 200); Container contentPane = this.getContentPane(); //contentPane.setLayout(null); contentPane.add(new JLabel(&quot;弹窗警告&quot;)); &#125;&#125; 标签构造方法 1new JLabel(&quot;xxx&quot;) Icon如何画一个标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;/*图标，继承Frame类，实现Icon接口 */public class IconDemo01 extends JFrame implements Icon &#123; //属性：宽高 private int width; private int height; //构造器 public IconDemo01() &#123; &#125; public IconDemo01(int width, int height) &#123; this.width = width; this.height = height; &#125; //初始化方法 public void init() &#123; setBounds(0, 0, 800, 600); //图标放在标签上 IconDemo01 iconDemo01 = new IconDemo01(15,15); JLabel jLabel = new JLabel(&quot;图标&quot;, iconDemo01 , SwingConstants.CENTER); Container container = getContentPane(); container.add(jLabel); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; //main方法 public static void main(String[] args) &#123; //通过调用new IconDemo01()的init()方法来 new IconDemo01().init(); &#125; //重写接口Icon的方法 @Override public void paintIcon(Component c, Graphics g, int x, int y) &#123; //画图标，画一个圆 g.fillOval(x, y, width, height); &#125; @Override public int getIconWidth() &#123; return width; &#125; @Override public int getIconHeight() &#123; return height; &#125;&#125; 图片标签ImageIcon1234567891011121314151617181920212223242526272829303132package cn.linsip.lesson04;import javax.swing.*;import java.awt.*;import java.net.URL;public class ImageIconDemo extends JFrame &#123; public ImageIconDemo() &#123; //获取图片的地址 URL url = ImageIconDemo.class.getResource(&quot;Hush a by little girl.jpg&quot;); ImageIcon imageIcon = new ImageIcon(url); //new JLabel标签 JLabel jLabel = new JLabel(); jLabel.setIcon(imageIcon); jLabel.setHorizontalAlignment(SwingConstants.CENTER); //把JLabel标签放面板上 Container container = getContentPane(); container.add(jLabel); pack(); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new ImageIconDemo(); &#125;&#125; 面板JPanel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JPanelDemo extends JFrame &#123; public JPanelDemo() &#123; //容器 Container container = getContentPane(); container.setLayout(new GridLayout(2,2, 10, 10)); //面板 JPanel jPanel1 = new JPanel(new GridLayout(1, 3)); JPanel jPanel2 = new JPanel(new GridLayout(1, 2)); JPanel jPanel3 = new JPanel(new GridLayout(2, 1)); JPanel jPanel4 = new JPanel(new GridLayout(3, 2)); //添加jButton按钮到JPanel面板 jPanel1.add(new JButton(&quot;1&quot;)); jPanel1.add(new JButton(&quot;1&quot;)); jPanel1.add(new JButton(&quot;1&quot;)); jPanel2.add(new JButton(&quot;2&quot;)); jPanel2.add(new JButton(&quot;2&quot;)); jPanel3.add(new JButton(&quot;3&quot;)); jPanel3.add(new JButton(&quot;3&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); jPanel4.add(new JButton(&quot;4&quot;)); //添加jPanel面板到容器中 container.add(jPanel1); container.add(jPanel2); container.add(jPanel3); container.add(jPanel4); setBounds(0, 0, 400, 400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JPanelDemo(); &#125;&#125; JScroll面板 1234567891011121314151617181920212223242526272829package cn.linsip.lesson01;import javax.swing.*;import java.awt.*;public class JScrollDemo extends JFrame &#123; public JScrollDemo() &#123; Container container = getContentPane(); //文本域 JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(&quot;Hello World!&quot;); JScrollPane jScrollPane = new JScrollPane(jTextArea); container.add(jScrollPane); setBounds(0, 0, 400, 400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JScrollDemo(); &#125;&#125; 按钮图片按钮 1234567891011121314151617181920212223242526272829303132package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;import java.net.URL;public class JButtonDemo01 extends JFrame &#123; public JButtonDemo01() &#123; Container container = getContentPane(); URL resource = JButtonDemo01.class.getResource(&quot;wechat.jpg&quot;); Icon icon = new ImageIcon(resource); JButton jButton = new JButton(); jButton.setIcon(icon); jButton.setToolTipText(&quot;图片按钮&quot;); container.add(jButton); setVisible(true); setSize(400,400); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo01(); &#125;&#125; 单选按钮 1234567891011121314151617181920212223242526272829303132333435363738package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JButtonDemo02 extends JFrame &#123; public JButtonDemo02() &#123; Container container = getContentPane(); //URL resource = JButtonDemo01.class.getResource(&quot;wechat.jpg&quot;); //Icon icon = new ImageIcon(resource); JRadioButton jRadioButton1 = new JRadioButton(&quot;jRB1&quot;); JRadioButton jRadioButton2 = new JRadioButton(&quot;jRB2&quot;); JRadioButton jRadioButton3 = new JRadioButton(&quot;jRB3&quot;); ButtonGroup buttonGroup = new ButtonGroup(); buttonGroup.add(jRadioButton1); buttonGroup.add(jRadioButton2); buttonGroup.add(jRadioButton3); container.add(jRadioButton1,BorderLayout.CENTER); container.add(jRadioButton2,BorderLayout.NORTH); container.add(jRadioButton3,BorderLayout.SOUTH); setSize(400,400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo02(); &#125;&#125; 复选按钮 1234567891011121314151617181920212223242526272829package cn.linsip.lesson05;import javax.swing.*;import java.awt.*;public class JButtonDemo03 extends JFrame &#123; public JButtonDemo03() &#123; Container container = getContentPane(); JCheckBox jCheckBox1 = new JCheckBox(&quot;jCheckBox1&quot;); JCheckBox jCheckBox2 = new JCheckBox(&quot;jCheckBox2&quot;); JCheckBox jCheckBox3 = new JCheckBox(&quot;jCheckBox3&quot;); container.add(jCheckBox1,BorderLayout.NORTH); container.add(jCheckBox2,BorderLayout.CENTER); container.add(jCheckBox3,BorderLayout.SOUTH); setSize(400,400); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new JButtonDemo03(); &#125;&#125; 列表下拉框 12345678910111213141516171819202122232425262728package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestComboboxDemo01 extends JFrame &#123; public TestComboboxDemo01() &#123; Container container = getContentPane(); JComboBox jComboBox = new JComboBox(); jComboBox.addItem(&quot;1&quot;); jComboBox.addItem(&quot;2&quot;); jComboBox.addItem(&quot;3&quot;); jComboBox.addItem(null); container.add(jComboBox); setSize(100,100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestComboboxDemo01(); &#125;&#125; 列表框 123456789101112131415161718192021222324252627282930313233package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;import java.util.Vector;public class TestComboboxDemo02 extends JFrame &#123; public TestComboboxDemo02() &#123; Container container = getContentPane(); //生成列表内容 //String[] strings = &#123;1 ,2 , 3&#125;; Vector contents = new Vector(); JList jList = new JList(contents); contents.add(&quot;111&quot;); contents.add(&quot;222&quot;); contents.add(&quot;333&quot;); container.add(jList); setSize(100,100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestComboboxDemo02(); &#125;&#125; 应用场景 选择地区，一般是单个选项 列表展示信息，一般是动态扩容 文本框文本框 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo01 extends JFrame &#123; public TestTextDemo01() throws HeadlessException &#123; Container container = getContentPane(); JTextField jTextField1 = new JTextField(&quot;jTextField1&quot;); JTextField jTextField2 = new JTextField(&quot;jTextField2&quot;); container.add(jTextField1, BorderLayout.NORTH); container.add(jTextField2, BorderLayout.SOUTH); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo01(); &#125;&#125; 密码框 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo02 extends JFrame &#123; public TestTextDemo02() &#123; Container container = getContentPane(); JPasswordField jPasswordField = new JPasswordField(); jPasswordField.setEchoChar(&#x27;*&#x27;); container.add(jPasswordField); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo02(); &#125;&#125; 文本域 123456789101112131415161718192021222324252627package cn.linsip.lesson06;import javax.swing.*;import java.awt.*;public class TestTextDemo03 extends JFrame &#123; public TestTextDemo03() &#123; Container container = getContentPane(); JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(&quot;Hello World!&quot;); JScrollPane jScrollPane = new JScrollPane(jTextArea); container.add(jScrollPane); setSize(100, 100); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new TestTextDemo03(); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java, GUI","slug":"Java-GUI","permalink":"http://example.com/tags/Java-GUI/"}]},{"title":"JavaSE自学笔记","slug":"JavaSE自学笔记","date":"2021-04-30T13:29:12.000Z","updated":"2021-05-15T08:36:47.509Z","comments":true,"path":"2021/04/30/JavaSE自学笔记/","link":"","permalink":"http://example.com/2021/04/30/JavaSE%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程","text":"JavaSE自学笔记（本人所看b站视频狂神说Java）初识Java博客自建博客 [Hexo博客的搭建与部署](Hexo博客的搭建部署 - Linsip) MarkDown语法[MarkDown语法笔记](Markdown语法 - Linsip) 常用Dos命令1234567891011121314151617181920212223242526272829303132//退回上级目录cd .. //退回到根目录cd\\//进入某文件夹cd 文件夹路径 //新建文件夹md 文件夹名//删除文件夹rd 文件夹名//拷贝文件copy 文件路径 目标路径 文件//删除文件del 文件路径 文件//查看目录下所有文件dir 路径//格式化硬盘（别乱用！！！！）format 盘符//清理屏幕（clean screen）cls//退出exit 计算机语言发展史(简史)计算机语言可以分为机器语言、汇编语言、高级语言三类，其对应的计算机语言发展历史的三个阶段 第一阶段 1946年2月14日，世界上第一台计算机ENAC诞生，使用的是最原始的穿孔卡片。这种卡片上使用的语言是只有专家才能理解的语言，与人类语言差别极大，这种语言就称为机器语言。机器语言是第一代计算机语言。这种语言本质上是计算机能识别的唯一语言，人类很难理解。以后的语言就是在这个的基础上简化而来。虽然后来发展的语言能让人类直接理解但最终送入计算机的还是这种机器语言。 第二阶段 计算机语言发展到第二代，出现了汇编语言。汇编语言用助记符代替了操作码，用地址符号或标号代替地址码。这样就用符号代替了机器语言的二进制码。汇编语言也称为符号语言。比起机器语言，汇编大大进步了。尽管还是复杂，用起来容易出错，但在计算机语言发展史上是机器语言向更高级的语言进化的桥梁 第三阶段 当计算机语言发展到第三代时，就进入了“面向人类”的高级语言。高级语言是一种接近于人们使用习惯的程序设计语言。它允许用英文写计算程序，程序中的符号和算式也与日常用的数学式子差不多。高级语言发展于20世纪50年代中叶到70年代，流行的高级语言已经开始固化在计算机内存里了，比如 basic语言。现在，计算机语言仍然在不断的发展，种类也相当多，比如 FORTRAN语言， COBOL语言，C语言，C++，C#， PASCAO，JAVA等等。 原文请看：计算机语言的发展简史-马海祥博客 (mahaixiang.cn) Java的历史（简史）1991年4月，James Gosling领导的Green Project计划，致力于开发一种适用于各种电子性消费产品的程序架构，诞生了Java的前身–Oak 1995年5月23日，Oak被更名为Java，由Sun公司在Sun World上正式发布。第一次提出了“Write once,Run anywhere”的口号 ··· JDK JDK（Java Development Kit）称为Java开发包或Java开发工具，是一个编写Java的Applet小程序和应用程序的程序开发环境。JDK是整个Java的核心，包括了Java运行环境（Java Runtime Environment），一些Java工具和Java的核心类库（Java API）。 来源：百度百科 安装JDK：JDK官网 推荐下载Java SE 8或者Java SE 11 JRE Java运行环境（Java Runtime Environment，简称JRE）是一个软件，由太阳微系统所研发，JRE可以让计算机系统运行Java应用程序（Java Application）。 JRE的内部有一个Java虚拟机（Java Virtual Machine，JVM）以及一些标准的类别函数库（Class Library）。 来源：百度百科 HelloWorld第一行代码尝试用记事本写下下面这几行代码或者推荐使用Notepad++ 并且在命令提示符上编译运行出来 123456public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 编译型与解释型编译型：简单来说就像是一个翻译，对我们写的的源代码进行翻译，生成计算机能看得懂的可执行代码 解释型：一边翻译，一边执行 Java（解释型+编译型）：java是通过javac.exe编译成.class文件 然后通过jvm加载.class文件，然后调用java.exe执行文件。在此之前你要下载安装JDK并配置环境变量。 IDEA先了解什么是IDE 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。 来源：百度百科 IDEA业界公认最好的Java开发工具 下载：IDEA官网 安装：按自己需求安装，或者默认安装 配置环境变量 我的电脑–&gt;属性–&gt;高级系统设置–&gt;高级–&gt;环境变量 在打开的系统变量中新建变量，变量名：JAVA_HOME，变量值：JDK安装目录 系统变量中Path下添加如下内容%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 测试是否配置成功cmd 1java -version 基础语法注释单行注释 Line comment12345678910//注释 这就是注释的基本格式，到本行结束所有的字符被编译器忽略//public class Demo01 表示定义了一个类 名称为Demo01 修饰符为public，其中类名称必须与文件名称相同public class Demo01 &#123; //main方法，代表一个程序的起点 public static void main(String[] args) &#123; //打印输出语句（屏幕显示） System.out.println(&quot;Hello World!&quot;); &#125;&#125; 多行注释 block comment1234567891011/*多行注释多行注释多行注释 */public class Demo02 &#123; public static void main(String[] args) &#123; System.out.println(&quot;China NO.1!&quot;); &#125;&#125; 文档注释JavaDoc12345/***@author*@version*@since*/ 参数 参数信息 @author 作者 @version 版本号 @since 指明最早使用jdk版本 @param 参数名 @return 返回值 @throws 抛出异常情况 拓展：如何用IDEA生成自己的api文档？ Tools——Generate JavaDoc 标识符定义Java的所有组成部分都需要名字。类名、变量名、方法名都被称为标识符 命名规则类名：首字母大写的驼峰命名，例如 1public class Demo &#123;&#125; 变量名：首字母小写的驼峰命名规则 12int num = 10;int getNum = 100; 方法名：首字母小写的驼峰命名规则 1void getMax() &#123;&#125; 注意事项 所有的标识符都应该以字母A-Z,a-z美元$或者下划线**_**开始 标识符大小写敏感 标识符可以用中文但是不建议 不得使用Java中的关键字作为标识符 关键字什么是关键字？有特殊含义的，被保留的，不能随意使用的字符 java中一共有53个关键字（不用记忆） Java常用关键字： abstract default if private this boolean do implements protected throw break double import public throws byte else instanceof return transient case extends int short try catch final interface static volatile char finally long strictfp while class float native super const for new switch continue goto package synchronized 注意事项 关键字都是是完全小写的字母 Java中的true和false不是关键字 Java中有两个特殊关键字（Java保留字，Java不用，你也不能用）goto，const。 数据类型java是一种强类型语言，即java的变量的使用要严格符合规定，先定义再使用 强类型语言：所有变量的定义必须严格符合规定，必须先定义后使用。安全性高，速度慢 弱类型语言： JS VB Java的数据类型分为基本数据类型和引用类型 基本数据类型8种基本数据类型primitive type 整数类型 类型 占位 最值 注 byte 8bit 0x7f~0x80 (127) short 16bit 0x7fff~0x8000 (32767) int 32bit 0x7fffffff~0x80000000 (21亿) long 64bit … 字面量需要使用L后缀 代码如下 12345678910111213141516171819202122232425public class Demo01&#123; public static void main(String[] args)&#123; //八大基本数据类型 //整数类型 int num1 = 10;//最常用 byte num2 = 20; short num3 = 30; long num4 = 40L;//long类型要在数字后加一个L //浮点数 float num5 = 10.1F;//float类型要在数字后面加F double num6 = 3.14; //字符 char name = &#x27;a&#x27;; //字符串，String不是关键字，是一个类 //String name = &quot;马林&quot;; //布尔值 boolean flag = true; &#125;&#125; 浮点类型 float（浮点型）:32bit double（双精度）:64bit 类型 占位 最值 注 float 32 (-2^31)~(2^31-1) float类型精度过低，很少使用（一般都用double），字面量后缀F double 64 浮点数的字面量默认为double，字面量后缀D 字符类型 char（字节型）:16bit 类型 占位 取值 注 char 16 0~2^16-1 char是一个2进制数（16位无符号整数），这个数值是一个unicode编码 编码拓展 某个数除了表示一个数之外，还可以表示为一个字符 Unicode编码是全球范围内的编码方法 12345678910111213package datatype;/*编码拓展Unicode编码65--A97--a */public class Demo02 &#123; public static void main(String[] args) &#123; char c = 65; System.out.println(c);//A &#125;&#125; 特殊字符用转义字符表示 转义字符 代表的意思 \\n 回车 \\t 制表 ··· 布尔类型 boolean类型：用于表达真假。常用于判断语句。 类型 占位 取值 注 boolean 1 false true 默认值为false 引用类型reference type类： 接口： 数组： 类型转换Java是强类型语言，进行有些运算的时候需要用到类型转换。 不同类型的数据先转换为同一类型的数据，然后进行计算 123char c = &#x27;a&#x27;;int i = 1;System.out.println((int)c+i);//98 基本数据类型转换基本数据类型转换分为强制类型转换和自动类型转换（隐式类型转换） 自动类型转换方向 char–&gt;int–&gt;long–&gt;float–&gt;double byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double 强制类型转换方向 char&lt;–int&lt;–long&lt;–float&lt;–double byte&lt;–short&lt;–int&lt;–long&lt;–float&lt;–double 强制类型转换会出现内存溢出的情况 123int i = 128;byte b = (int)i;//内存溢出System.out.println(b);//-128 也可能有精度问题 123double d1 = 20.7;int i = (int)d1;System.out.println(i);//20 操作比较大的数的时候注意溢出问题 1234567891011public class Demo public static void main(String[] args)&#123; int money = 10_0000_0000;//JDK7的新特性，数字之间加_用于区分数字，计算不受影响 int year = 20; int total = money*year;//计算的时候溢出了 long total2 = money*year;//默认类型int，右边在计算之前就出现问题 System.out.println(total);//-1474836480 System.out.println(total2);//-1474836480 //解决方法：在计算之前先转换数据类型 long total3 = money*(long)year;&#125; 自动类型转换 低–高，不会存在内存溢出的问题。 注意点 不能对布尔类型进行转换 不能将变量类型转换为不相干的类型 把高容量数据转换为低容量数据 ，须强制转换 转换的时候会有内存溢出或者精度问题的情况 引用类型转换向下转型：小类型转大类型 向上转型：大类型转小类型 instanceof：检查引用对象的类型 变量与常量变量变量就是可以变化的量 Java变量是程序的最基本的存储单元，其要素包括变量名、变量类型和作用域。 12数据类型 变量名 = 值;可以用逗号隔开用于声明多个同类型变量。type varName [=value] [&#123;,varName[=value]&#125;]; 注意事项 每个变量都有其类型，可以是基本类型，也可以是引用类型。 变量名必须为合法的标识符。 变量的声明是一条完整的语句，因此每个声明都必须以分号结束。 变量的作用域 类变量 实例变量 局部变量 1234567public class Variable&#123; static int allClicks = 0;//类变量 加了static的变量 从属于类，随着类出现和消失 String str = &quot;hello world!&quot;;//实例变量:从属于对象，在类的里面，方法的外面，如果不进行初始化，则会变为该数据类型的默认值 0 0.0 u0000 false null（除了基本类型其他的都是null） public void method()&#123; int i = 0;//局部变量 &#125;&#125; 12345678910111213141516171819202122232425public class Demo &#123; //类变量 static static int salary = 2500; //属性：变量，类里面除了方法还可以定义一些属性 //实例变量，从属于对象 String name; int age; //main方法 public static void main[String[] args]&#123; //局部变量；必须声明和初始化值 int i = 10; System.out.println(i); //变量类型 变量名 = new Demo(); Demo demo = new Demo(); System.out.println(demo.name); System.out.println(demo.age); &#125; public void add()&#123; System.out.println(i); &#125;&#125; 变量的命名规范 所有的变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 常量：大写字母和下划线 MAX_VALUE 类名：首字母大写和驼峰原则 Demo 方法名：首字母小写和驼峰原则 run() getMax() 常量：初始化后不能改变的值 常量可以理解为一种特殊的变量，他的值被设定后，在程序运行期间不会改变。 常量名一般用大写字母表示 12final 常量名 = 常量值；final PI = 3.14; 123456789public class Demo&#123; static final double PI = 3.14;//修饰符不分前后 public static void main [String[] args]&#123; System.out.println(PI); &#125;&#125; 运算符算数运算符123456789101112131415public class Demo01&#123; //算数运算符 public static void main[String[] args]&#123; int a = 10; int b = 20; int c = 30; int d = 40; int e = 21; System.out.println(a+b);//30 System.out.println(a-b);//-10 System.out.println(a*b);//200 System.out.println(a/(double)b);//0.5 System.out.println(e%a);//%取余 也叫模运算 即21/10=2...1 21%10=1 &#125;&#125; 注意事项 整数除法运算，会出现下溢出现象 1234567public class Demo02 &#123; public static void main(String[] args) &#123; int a = 4; int b = 3; System.out.println(a/b);//1 下溢出，余数1被舍弃 &#125;&#125; 低于int类型（short）（byte）的运算都按int类型运算 12345678910111213public class Demo &#123; public static void main[String[] args]&#123; long a = 111222333222111L; int b = 123; short c = 10; byte d = 8; // System.out.println(a+b+c+d);//Long System.out.println(b+c+d);//Int System.out.println(C+D);//Int &#125;&#125; 模运算 （%）表示计算除法的余数 ​ 0对其他数的余数为0 ​ 负数的余数是负数 1234567891011121314package datatype;public class Demo &#123; public static void main(String[] args) &#123; int i1 = 11; int i2 = 2; int i3 = 0; int i4 = -11; System.out.println(i1 % i2);//1 System.out.println(i3 % i2);//0 System.out.println(i4 % i2);//-1 &#125;&#125; 自增自减 123456789101112public class Demo&#123; public static void main(String[] args)&#123; //++ -- 自增 自减 int a = 3; int b = a++;//表示a先赋值给b，然后再自增1 System.out.println(a);//4 int c = ++a;//表示a先自增1，然后赋值给c System.out.println(a);//5 System.out.println(b);//3 System.out.println(c);//5 &#125;&#125; 赋值运算符=赋值运算符表示把等号右边的赋值给左边 ==才是现实意义上的等于，属于关系运算符 关系运算符12345678910public class Demo&#123; public static void main (String[] args)&#123; //关系运算符，返回的是布尔值 false true int a = 10; int b = 20; System.out.println(a&gt;b); System.out.println(a&lt;b); System.out.println(a==b); &#125;&#125; 逻辑运算符123456789101112131415161718//逻辑运算符public class Demo&#123; pubic static void main(String[] args)&#123; //&amp;&amp;与 ||或 !非 boolean a = true; boolean b = false; System.out.println(&quot;a&amp;&amp;b:&quot;+(a&amp;&amp;b)); System.out.println(&quot;a||b&quot;+(a||b)); System.out.println(&quot;!(a&amp;&amp;b)&quot;+!(a&amp;&amp;b)); //短路运算,进行逻辑与运算时会发生短路运算 int c = 5; boolean d = (c&lt;4)&amp;&amp;(c++&lt;4);//这里发生了短路运算，与运算下，c&lt;4为false，计算机就不会计算&amp;&amp;后面的c++&lt;4,所以c还是5，不会自增 System.out.println(c);//5 System.out.println(d);//false &#125;&#125; 位运算符12345678910111213141516171819202122232425262728//位运算public class Demo&#123; /* A = 0011 1100 B = 0000 1101 A&amp;B = 0000 1100 如果A与B两个二进制数对应位上都为1，结果才为1，否则就是0 A|B = 0011 1101 如果A与B两个二进制数对应位上都为0，结果才为0，否则就是1 A^B = 0011 0001 如果A与B两个二进制数相对应位上相同就为0，不同就为1 ~B = 1111 0010 取反 2*8怎么运算最快？2*2*2*2 0000 0000 0 0000 0001 1 0000 0010 2 0000 0011 3 0000 0100 4 ... 0001 0000 16 &lt;&lt; *2 &gt;&gt; /2 */ public static void main(String[] args)&#123; //2*8怎么运算最快？2*2*2*2 System.out.println(2&lt;&lt;3); &#125;&#125; 拓展 如何进行幂运算 1234567public class Demo&#123; public static void main(String[] args)&#123; //幂运算 很多运算需要用到一些工具类 double pow = Math.pow(2,3);//2^3 Math工具类位于Java.lang包下，其方法都是静态方法，直接类名.方法名就可以使用 System.out.println(pow); &#125;&#125; 条件运算符 1234567891011//三元运算符public class Demo &#123; public static void main&#123; //x?y:z //如果x为true，结果就为y，否则就为z int score = 80; String type = score&lt;60?&quot;不及格&quot;:&quot;及格&quot;; System.out.println(type);//及格 &#125;&#125; 拓展赋值运算符 12345678910111213141516//拓展运算符public class Demo&#123; public static void main(String[] args)&#123; int a = 10; int b = 20; a+=b; a-=b; a*=b; a/=b; //字符串连接符+ +遇到String类型的会变为字符串连接符 System.out.println(&quot;&quot;+a+b);//1020 System.out.println(a+b+&quot;&quot;);//30 &#125;&#125; 1234567891011121314public class Demo &#123; public static void main[String[] args]&#123; long a = 111222333222111L; int b = 123; short c = 10; byte d = 8; // System.out.println(a+b+c+d);//Long System.out.println(b+c+d);//Int System.out.println(C+D);//Int &#125;&#125; 包机制为了更好的组织类，java提供了包机制，用于区别类名的命名空间 包语句的语法格式 1package pkg1[.pkg2[.pkg3...]]; 一般利用公司域名的倒置作为包名比如www.baidu.com&gt;com.baidu.www 为了使用某一个包的成员，我们需要在java程序中导入该包。 1import package1[.package2...].(classname|*); JavaDoc用idea生成api帮助文档 Tools–&gt;Generate JavaDoc 流程控制Scanner类Scanner类的hasNext()与hasNextLine()判断是否还有输入的数据 通过Scanner类的next()与nextLine()方法获取输入的字符串 示例一： 123456789101112131415import java.util.Scanner;//导包语句，Idea自动生成public class ScannerDemo &#123; public static void main(String[] args)&#123; //创建一个Scanner对象 Scanner scanner = new Scanner(System.in); //判断用户有没有输入字符串 if (scanner.hasNext())&#123; // String str = scanner.next(); System.out.println(&quot;输入的内容为：&quot;+str); &#125; //关闭scanner，凡是属于IO流的类不关闭就会一直占用资源 scanner.close(); &#125; &#125; 示例二： 1234567891011121314151617181920import java.util.Scanner;public class ScannerDemo02 &#123; public static void main(String[] args) &#123; //创建一个Scanner对象 Scanner scanner = new Scanner(System.in); //提示用户输入 System.out.println(&quot;输入名字&quot;); //判断用户是否输入 if (scanner.hasNextLine()) &#123; //String类用于接收 String name = scanner.nextLine(); //打印出名字 System.out.println(name); &#125; //关闭scanner，减少资源占用 scanner.close(); &#125;&#125; next(): 一定读取到有效字符后才结束输入 有效字符前的空格，会被方法忽略 有效字符后面的空格，会被方法当为结束符 next()方法不能得到带有空格的字符串 nextLine(): 以回车作为结束符 可以获得空格 练习题1：输入多个数字，并求出总和与平均数，通过非数字的输入来结束输出并输出执行结果 12345678910111213141516171819202122import java.util.Scanner;public class ScannerDemo03 &#123; public static void main(String[] args) &#123; //定义两个变量用于后面的求和与计算平均数 double sum = 0; int num = 0; //new一个Scannner类的对象 Scanner scanner = new Scanner(System.in); //用循环来判断是否输入的是数字，以及求和，累计数字个数 while (scanner.hasNextDouble()) &#123; sum += scanner.nextDouble(); num++; &#125; //输出结果 System.out.println(&quot;输入数字的个数为&quot; + num); System.out.println(&quot;输入数字的和为：&quot; + sum); System.out.println(&quot;输入数字的平均数为&quot; + (sum / num)); //关闭scanner scanner.close(); &#125;&#125; 顺序结构顺序结构是Java的基本结构，除非特别指明，否则就按从上到下，从左到右，一句一句的执行。 顺序结构是最基本的算法结构，是任何算法都离不开的一种基本算法结构。 选择结构if - else语句 基本语法： if单选择结构语法 123if (布尔表达式) &#123; 语句&#125; if双选择结构语法 12345if(布尔表达式)&#123; 语句1&#125;else &#123; 语句2&#125; if多选择结构语法 123456789if(布尔表达式1)&#123; 语句1&#125;else if(布尔表达式2)&#123; 语句2&#125;else if(布尔表达式3)&#123; 语句3&#125;else&#123; 语句4&#125; 示例 12345678910public class IfDemo &#123; public static void main (String[] args)&#123; int i = 1; if(i==1)&#123; System.out.println(&quot;Hello World!&quot;); &#125;else&#123; System.out.println(&quot;你好，世界！&quot;) &#125; &#125;&#125; 练习1:输入成绩，判断成绩，60以上成绩合格，60以下成绩不合格 123456789101112131415161718public class IfDemo &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入成绩：&quot;); if (scanner.hasNextInt()) &#123; int i = scanner.nextInt(); if (i &gt;= 60 &amp;&amp; i &lt;= 100) &#123; System.out.println(&quot;成绩合格&quot;); &#125; else if (i &gt;= 0 &amp;&amp; i &lt; 60) &#123; System.out.println(&quot;成绩不合格&quot;); &#125; else &#123; System.out.println(&quot;非法成绩！！！&quot;); &#125; &#125;else&#123; System.out.println(&quot;请输入整数！！！&quot;); &#125; &#125;&#125; switch - case语句 基本语法 1234567switch () &#123; case 字面量: 代码; break; default 字面量: 代码;&#125; 注意点 switch不能处理long类型，Java se7开始 switch支持String类型 case后面必须为数字或者字面量，不能写语句 default表示没有满足case条件的其他一切情况 不要忘记写break，不写会出现”case穿透“，后面的case、default都会执行 循环结构while循环 基本语法 123while (布尔表达式) &#123; 循环体&#125; 示例 12345678910public class WhileDemo &#123; public static void main(String[] args) &#123; //输出1~100 int i = 0; while (i&lt;100)&#123; i++; System.out.println(i); &#125; &#125;&#125; 注意点 循环体内一定要有能让布尔表达式为false的情况，否则就是死循环，会一直执行循环体 死循环 当我们有特殊需求需要使用死循环的时候 例如：输出0~无限大 123456789public class WhileDemo01 &#123; public static void main(String[] args) &#123; int i = 0; while (true) &#123; i++; System.out.println(i); &#125; &#125;&#125; 尽量不要这么写，cpu会卡死！！！ do - while循环 基本语法 123do &#123; //循环体语句&#125; while (布尔表达式); 相对于while循环，do-while循环会至少执行一次循环体 示例 1234567891011121314public class DoWhileDemo &#123; public static void main(String[] args) &#123; int a = 0; while (a &lt; 0) &#123; a++; System.out.println(a); &#125; do &#123; a++; System.out.println(a);//这里会输出1 &#125; while (a &lt; 0); &#125;&#125; for循环 基本语法 123for (初始化语句;布尔表达式;更新) &#123; //循环体语句&#125; 注意点： 先执行初始化语句，初始化语句可以初始化一个或多个循环控制变量，也可以为空 然后执行布尔表达式，布尔表达式为true则执行一次循环体语句，之后是更新语句，布尔表达式，循环体语句……直到布尔表达式为false就执行终止循环 练习题1：计算0~100之间奇数与偶数的和 1234567```练习题2：用for循环输出1~1000之间能被5整除的数，每行三个```java 练习题3：打印九九乘法表 123456789101112```**增强for循环**Java5引入了一种主要用于数组或者集合的增强型for循环语法格式```javafor (声明语句:表达式) &#123; //代码&#125; 注意点 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环体语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名或者是返回值为数组的方法。 break &amp; continuebreak在任何循环体主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中的剩余语句。 continue语句实在循环体语句中，用于阻止某次循环，即跳过循环体中未执行的语句，接着进行下一次是否执行循环的判定。 拓展： goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式的使用；Java没有goto。然而在break和continue这两个关键字上，可以看到goto的影子————带标签的break和continue 标签是指后面跟一个冒号的标识符例如：label 对于Java来说，唯一用到标签的地方是在循环语句之前。在循环语句之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，因为break和continue关键字只会终止当前循环，但是如果和标签一起使用，他们就会中断到存在标签的地方 方法urn语句局部变量 方法的参数的参数定义，是临时变量（空壳，相当于声明变量而没有赋值） 例如 123456789101112public class MethodDemo&#123; public static void main (String[] args)&#123; //这里的sum()方法中的1，2就是实参 int a = sum(1,2); System.out.println(a); &#125; public static int sum (int a,int b)&#123;//这里的int a，int b就是形参 return a+b; &#125;&#125; 方法调用方法重载重载就是在一个类中，有相同的函数名称，但是形参不同的函数。 方法的重载必须满足下列规则： ​ 方法名称必须相同 ​ 参数列表必须不同 ​ 返回值类型可以相同也可以不同，仅仅返回值类型的不同不足以构成方法的重载。 实现理论： ​ 方法名称相同时，编译器会根据调用方法的参数个数、参数类型去逐个匹配，以选择对应的方法，如果匹配失败则编译器报错。 123456789101112131415161718192021222324252627282930313233343536373839public class Demo &#123; public static void main(String[] args)&#123; double max = max(10.1,10.0); System.out.println(max); &#125; //比大小 public static int max(int num1,int num2)&#123; int result = 0; if(num1==num2)&#123; System.out.println(&quot;num1==num2&quot;); return 0;//这里的return用于终止该方法。 &#125; if (num1&gt;num2)&#123; result = num1; &#125;else&#123; result = num2; &#125; return result; &#125; public static double max(double num1,double num2)&#123; double result = 0; if(num1==num2)&#123; System.out.println(&quot;num1==num2&quot;); return 0;//这里的return用于终止该方法。 &#125; if (num1&gt;num2)&#123; result = num1; &#125;else&#123; result = num2; &#125; return result; &#125;&#125; 命令行传参有时候你希望运行一个程序时再给它传递消息，这要靠传递命令行参数给main()函数实现。 1234567public class CommandLine &#123; public static void main(String[] args)&#123; for(int i =0;i&lt;args.length;i++)&#123; System.out.println(&quot;args[&quot;+i+&quot;]&quot;+args[i]); &#125; &#125;&#125; 可变长参数JDK1.5开始，Java支持传递同类型的可变参数给一个方法。 在方法声明中，在指定的参数类型后加一个省略号(…) 一个方法只能指定一个可变参数，它必须是方法的最后一个参数。任何普通参数必须在它之前声明。 可变参数的本质是一个数组 12345678910111213141516public static void printMax(double...numbers)&#123; if(numbers.length == 0)&#123; System.out.println(&quot;No argument passed!&quot;); return; &#125; double result = numbers[0]; // for (int i =1; i&lt;numbers.length;i++)&#123; if (numbers[i]&gt;result)&#123; result =numbers[i]; &#125; &#125; System.out.println(&quot;The max value is &quot;+result);&#125; 递归A方法调用B方法 递归就是：A方法调用A方法 利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需要少量的程序就可描述出解题过程中所需要的多次重复计算，大大减小了程序的代码量。递归的功能在于利用有限的语句来定义对象的无限集合。 递归结构包括两个部分： ​ 递归头：什么时候不调用自身方法。如果没有头将陷入死循环。 ​ 递归体：什么时候需要调用自身方法。 1234567891011121314public class Demo&#123; //递归 public static void main (String[] args)&#123; System.out.println(f(5)); &#125; public static int f(int n)&#123; if(n==1)&#123; return 1; &#125;else&#123; return n*f(n-1); &#125; &#125;&#125; 数组数组的定义数组是拥有相同数据类型数据的有序集合 其中，每个数据都称为数组的元素，每一个数组元素可以通过下表访问他们。（下标从0开始） 声明数组 12arrayType[] arrayRefVar;//首选写法arrayType arrayRefVar[];//也是数组的声明，但是不建议这样写（c和c++的数组是这样写的） 分配空间 1arrayRefVar = new arrayType[arraySize]; 声明数组和分配空间可以合并一句来写 1arrayType[] arrayRefVar = new arrayType[arraySize]; 赋值 数组是通过索引访问的，索引从0开始； 123arrayRefVar[0] = 1;arrayRefVar[1] = 2;... 没有赋值的数据元素有默认值，默认值和数组类型有关 处理数据 获取数组长度arrays.length 1arrayRefVar.length 示例 12345678910111213141516171819public class ArrayDemo01&#123; public static viod main (String[] args)&#123; //数组的声明 int[] array; //分配数组空间 array = new int[5]; //分配数值，数组下标从0开始 array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; array[4] = 5; //遍历数组 for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 数组的三种初始化 静态初始化：创建+赋值 12int[] array = &#123;1,2,3&#125;;//基本类型Man[] mans = &#123;new Man(),new Man()&#125;;//引用类型 动态初始化 1234int[] array = new int[3];array[0] = 1;array[1] = 2;array[2] = 3; 默认初始化 数组相当于引用类型，它的元素相当于类的实例变量，一旦数组被分配空间，其元素也就和类中的实例变量一样，被隐式初始化。 注意点 数组数据类型确定，不存在混合类型的数组 数组长度确定，数组一旦被创建，其长度就确定，而且不可改变 数组可以为任何数据类型，包括基本类型和引用类型 数组变量属于引用类型，也可以看为对象，每个数组元素可以看为该数组对象的成员变量，数组的本身就是对象，无论数组元素保存的是基本类型数据还是引用类型数据，数组都是保存在堆中的。 总结 数组是相同类型数据的有序集合 数组属于引用类型，数组也是对象，数组元素相当于成员变量 数组长度不可变 0~array.length-1，越界则会报错：ArrayIndexOutOfBoundsException即数组下标越界异常 最早遇到的错误 ArrayIndexOutOfBoundsException：数组下标越界异常 数组的使用for each循环 数组作为方法入参 数组作为返回值 二维数组二维数组：数组中嵌套数组，可以看为2行3列的数组 1int[][] arrays = new int[2][3]; 示例 12345678910111213141516171819202122232425262728293031323334353637package array;/*多维数组二维数组 */public class ArrayDemo02 &#123; public static void main(String[] args) &#123; /* 1,2 2,3 3,4 4,5 */ int[][] arrays =&#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;3,4&#125;,&#123;4,5&#125;&#125;; System.out.println(arrays[0]); printArray(arrays[0]); System.out.println(); System.out.println(arrays[0][0]); System.out.println(arrays[0][1]); //遍历二维数组 for (int i = 0; i &lt;arrays.length;i++) &#123; for (int j = 0; j &lt;arrays[i].length; j++) &#123; System.out.println(arrays[i][j]); &#125; &#125; &#125; //打印数组元素 public static void printArray(int[] arrays)&#123; for (int i = 0; i &lt;arrays.length; i++) &#123; System.out.print(arrays[i]+&quot; &quot;); &#125; &#125;&#125; Arrays工具类数组的工具类 java.util.Arrays 数组对象本身并没有什么方法供我们使用，但是我们可以借助API提供的Arrays工具类来帮我们对数组对象进行一些基本的操作 JDK帮助文档 Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名调用 Arrays类常用功能 给数组赋值：fill 对数组排序：sort 比较数组：equals 查找数组元素：binarySearch 排序算法冒泡排序 示例 1234567891011121314151617181920212223242526272829303132333435363738394041package array;import java.util.Arrays;/*冒泡排序比较相邻的两个数组元素，如果第一个数组元素比第二个数组元素大，那么便交换他们的位置每一次循环，都会产生一个最大，一个最小的下轮排序可以少一次排序一次循环直到结束 */public class ArrayDemo07 &#123; public static void main(String[] args) &#123; int[] arrays = &#123;12, 3, 4, 5, 76, 8, 89&#125;; int[] result = bubbleSort(arrays); System.out.println(Arrays.toString(result)); &#125; //冒泡排序 public static int[] bubbleSort(int[] a) &#123; //定义一个临时变量，用于内层循环交换数组元素 int temp = 0; //外层循环，判断循环多少次 for (int i = 0; i &lt; a.length - 1; i++) &#123; //内层循环，判断相邻两个数组元素的大小，并交换位置 for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; if (a[j + 1] &lt; a[j]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; //返回数组a return a; &#125;&#125; 面向对象面向对象与面向过程 面向过程 第一步…第二步… 面向对象适合处理一些较为简单的问题 面向对象 分类的思维，思考问题首先需要解决问题有那些分类，然后对于这些分类进行单独思考，最后对于分类下的细节进行面向过程的探索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题 对于复杂的事物，需要先从宏观上把握、从整体上分析，我们需要使用面向对象的思路来分析整个系统。然后在具体到微观细节，需要用面向过程的思路去解决。 属性+方法就是一个类 什么是面向对象 面向对象的本质就是：以类的方式组织代码，以对象的形式组织（封装）数据。 抽象 面向对象的三大特性 封装：把数据封装 继承：子类继承父类 多态： 如何理解类与对象 从认识论的角度：现有对象后有类。对象是具体的事物。类是抽象的，是对对象的抽象。 从代码角度考虑先有类后有对象，类是对象的模板 回顾方法 - 方法的定义 123456789101112131415161718192021222324package oop.review;import java.io.IOException;public class MethodRev &#123; //这是一个main方法 public static void main(String[] args) &#123; MethodRev methodRev = new MethodRev(); System.out.println(methodRev.sayHello()); &#125; //我们可以自定义一个方法来使用 public String sayHello() &#123; return &quot;Hello&quot;; &#125; //抛出异常，后面学 public String readFile(String file) throws IOException &#123; return null; &#125;&#125; - 方法的调用 12345678910111213141516171819package oop.review;/*静态方法：有static修饰的方法 带有static关键字的方法和类一起加载非静态方法：没有static修饰的方法 对象创建之后才存在 */public class Demo01 &#123; public static void main(String[] args) &#123; //静态方法的调用 Student.say(); //非静态方法的调用，先实例化这个类，然后在通过对象.方法名调用 Student student = new Student(); student.eat(); &#125;&#125; 12345678910111213141516171819202122package oop.review;/*静态方法可以直接调用静态方法静态方法不能直接调用非静态方法(要实例化之后，通过对象名.方法名调用)非静态方法可以直接调用静态方法 */public class Demo02 &#123; public static void a() &#123; b(); &#125; public static void b() &#123; a(); &#125; public void c() &#123; a(); &#125;&#125; 123456789101112131415161718package oop.review;public class Demo03 &#123; public static void main(String[] args) &#123; int sum = new Demo03().add(123, 123, 231); System.out.println(sum); &#125; public int add(int... a) &#123; int sum = 0; for (int i = 0; i &lt; a.length; i++) &#123; int num1 = a[i]; sum += num1; &#125; return sum; &#125;&#125; 12345678910111213package oop.review;public class Student &#123; public static void say() &#123; System.out.println(&quot;学生说话了&quot;); &#125; public void eat() &#123; System.out.println(&quot;学生吃东西了&quot;); &#125;&#125; 类与对象类是一种抽象的数据类型，它是对某一类整体事物的描述、定义，但是不能代表某一个具体的事物 比如说 Student类 Pet类等等都是用来描述、定义某一类事物该有的特点和行为 对象是抽象概念的具体实例 比如说张三家的小狗旺财就是Pet类的一个具体实例 简单小结类与对象 类与对象 类是一个抽象的 对象是具体的 方法 方法的定义、调用 对应的引用 引用类型：除了八大基本类型 对象通过引用来操作的：栈》》》堆 属性：字段 field 成员变量 默认初始化 数字：0 char：u0000 boolean：false 引用：null 修饰符 引用类型 属性名 = 属性值 对象的创建及使用 必须用new关键字创建对象 构造器 Person person = new Person() 对象的属性 person.name 对象的方法：person.sleep() 类 静态的属性 属性 动态的行为 方法 构造方法new对象创建与初始化对象 使用new关键字创建对象 1 使用new关键字创建对象的时候，除了分配内存空间外，还会给创建好的对象进行默认的初始化以及对类中的构造器的使用 封装该露的露，该藏的藏 我们设计程序追求高内聚，低耦合，高内聚是指类的内部数据的操作细节自己完成，不允许外部干涉；低耦合是指尽量暴露少的方法给外部使用 封装（数据的隐藏） 通常，应该禁止直接访问一个对象中的数据的实际表示，而是应该通过操作接口来访问，这成为信息的隐藏 属性私有，get/set 提高程序安全性，保护数据 隐藏代码实现细节 统一接口 提升系统的可维护性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package oop.demo04;/*get用来获取private修饰的数据set用来设置private修饰的数据 */public class Student &#123; private String name; private int age; private char sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; //睡觉 public void sleep() &#123; System.out.println(&quot;正在睡觉&quot;); &#125; //学习 public void study() &#123; System.out.println(&quot;正在学习&quot;); &#125;&#125; 继承继承的本质是对一批类的抽象，从而实现对世界的更好的建模 extends：本意拓展，子类是父类的拓展 12345678910111213141516171819202122package oop.demo04;public class Person &#123; /* 修饰符 public 公共的，都可以访问 protected default private 私有的，属于本类的 子类继承父类，只能继承父类public修饰的属性、方法 */ public int money = 10_0000_0000; public void say()&#123; System.out.println(&quot;说了一句话&quot;); &#125;&#125; 123456package oop.demo04;//学生is Personpublic class Student extends Person&#123;&#125; 123456package oop.demo04;//学生is Personpublic class Student extends Person&#123;&#125; 1234567891011121314151617181920package oop;import oop.demo04.Student;/*规范：一个项目应该只存在一个main方法 */public class Application &#123; public static void main(String[] args) &#123; Student s1 = new Student(); //Student类里面没有say()方法，Student类继承了Person类，可以执行Person类里面的Say()方法 s1.say(); &#125;&#125; java只有单继承没有多继承 继承是类与类之间的关系，类与类的关系还有依赖、组合、聚合等 具有继承关系的两个类，一个叫子类，一个叫父类，子类继承父类，用关键字extends表示 object类 java中所有的类默认继承Object类，Object类是所有类的超级父类 快捷键ctrl+h：查看层级结构 super 调用父类的构造方法 必须只能出现在子类的方法或者构造方法中 super和this不能同时出现在构造方法中 vs this this：代表本身调用者这个对象，没有继承也可以用 super：代表父类对象的引用，只能在继承关系下使用 构造方法 this():调用本类的构造 super():调用父类的构造 方法的重写 12345678910111213141516171819202122232425package oop;import oop.demo05.A;import oop.demo05.B;/*规范：一个项目应该只存在一个main方法 */public class Application &#123; public static void main(String[] args) &#123; //方法的调用之和左边的类型有关 A a = new A(); a.test(); //父类的引用指向子类对象 B b = new A(); b.test(); &#125;&#125; 12345678package oop.demo05;public class A extends B&#123; public static void test()&#123; System.out.println(&quot;A&gt;test&quot;); &#125;&#125; 1234567891011package oop.demo05;/*重写：重写是方法的重写，与属性无关 */public class B &#123; public static void test()&#123; System.out.println(&quot;B&gt;test&quot;); &#125;&#125; 12345678910111213package oop.demo05;public class A extends B&#123; @Override//注解，有功能的注释 public void test() &#123; System.out.println(&quot;A&gt;test&quot;); &#125;&#125;/*静态方法和非静态方法有很大的区别静态方法不能被重写，静态方法的调用只和左边的类型有关非静态方法可以被重写(只能是public的方法)，他的调用只和new */ 1234567891011package oop.demo05;/*重写：重写是方法的重写，与属性无关 */public class B &#123; public void test()&#123; System.out.println(&quot;B&gt;test&quot;); &#125;&#125; 123456789101112131415161718192021222324252627package oop;import oop.demo05.A;import oop.demo05.B;/*规范：一个项目应该只存在一个main方法 */public class Application &#123; public static void main(String[] args) &#123; //方法的调用之和左边的类型有关 A a = new A(); a.test(); //父类的引用指向子类对象 B b = new A(); b.test(); &#125;&#125; 重写是方法的重写，与属性无关 重写注意点 重写必须有继承关系 参数列表必须相同 修饰符：可以被扩大，不可以被缩小 private&lt; default&lt; protected&lt; public 抛出的异常：可以被缩小，不能被扩大 为什么需要重写 父类的方法子类不一定需要或者满足alt insert&gt;&gt;&gt;override 多态同一方法可以根据发送方法的不同，采取多种不同的行为方式 一个对象的实际类型是确定的，但是可以指向对象的引用的类型有很多 多态的前提 有继承关系 子类重写父类方法 父类引用指向子类对象 多态是方法的多态，属性没有多态性 intsanceof 1234567891011121314151617181920212223242526272829package oop;import oop.demo06.Person;import oop.demo06.Student;import oop.demo06.Teacher;public class Application &#123; public static void main(String[] args) &#123; Object o = new Student(); System.out.println(o instanceof Student);//ture System.out.println(o instanceof Person);//ture System.out.println(o instanceof Object);//ture System.out.println(o instanceof Teacher);//false System.out.println(o instanceof String);//false /* 思考 Person Student Teacher */ &#125;&#125; 12345package oop.demo06;public class Teacher &#123;&#125; 12345678package oop.demo06;public class Person &#123; public void run()&#123; System.out.println(&quot;run&quot;); &#125;&#125; 12345678910111213package oop.demo06;public class Student extends Person&#123; @Override public void run() &#123; System.out.println(&quot;s run&quot;); &#125; public void eat()&#123; System.out.println(&quot;s eat&quot;); &#125;&#125; 注意点 多态是方法的多态 子类父类，不是继承关系会有类型转换异常ClassCastException 多态的前提 static方法不能被重写 final方法不能被重写 private方法不能被重写 1234567891011121314151617181920212223242526272829303132333435package oop;import oop.demo06.Person;import oop.demo06.Student;public class Application &#123; public static void main(String[] args) &#123; /* 一个对象的类型是确定的 new Student(); new Person(); 可以指向的引用可以不同 Person s1 = new Student(); Student s2 = new Student(); */ Student s1 = new Student(); Person s2 = new Student(); Object s3 = new Student(); //Student能调用的方法都是自己的，或者继承父类的 s1.run(); //Person能调用的方法只能是 s2.run(); s1.eat(); ((Student)s2).eat(); &#125;&#125; 12345678package oop.demo06;public class Person &#123; public void run()&#123; System.out.println(&quot;run&quot;); &#125;&#125; 12345678910111213package oop.demo06;public class Student extends Person&#123; @Override public void run() &#123; System.out.println(&quot;s run&quot;); &#125; public void eat()&#123; System.out.println(&quot;s eat&quot;); &#125;&#125; 修饰符抽象类 123456789101112131415package oop.demo08;/*abstract抽象类抽象类不能new出来，只能靠子类去实现他抽象类里面可以写普通方法，但是抽象方法只能在抽象类中抽象的抽象：约束抽象类是否存在构造器 */public abstract class Action &#123;//约束，有人帮我们完成某些功能的具体实现 //抽象方法，abstract修饰的方法，只有方法的名字没有方法的实现 public abstract void doSomething();&#125; 123456789101112package oop.demo08;/*抽象类的所有方法都必须由子类实现（重写），除非子类也是抽象的 */public class A extends Action&#123; @Override public void doSomething() &#123; &#125;&#125; 接口普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…你必须能…”的思想 接口的本质就是契约，制定好后大家都要遵守 OO的精髓是对对象的抽象，最能体现这一点的就是接口，我们讨论设计模式都是针对具备抽象能力的语言（c,java,c#）,设计模式研究的就是如何去抽象 interface声明接口 class声明类 作用： 约束 定义一些不同的方法，让不同的人去实现 public abstract public static final 接口不能被实例化，接口没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类内部类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就是一个内部类，或者说A类相对于B类是外部类 成员内部类 ```javapackage oop.demo10; public class Outer { private int id = 100; public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125; public class Inner&#123; public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125; public void getId()&#123; System.out.println(id); &#125; &#125; } 1234567891011121314151617181920212223242526 2. 2. 静态内部类 1. static 2. ```java package oop.demo10; public class Outer &#123; private int id = 100; public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125; public static class Inner&#123; public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125; public void getId()&#123; System.out.println(id); &#125; &#125; &#125; 局部内部类 ```javapackage oop.demo10;public class Outer {//局部内部类public void out()&#123; class Inner&#123; public void in()&#123; &#125; &#125; &#125; }1234567891011121314151617181920212223 2. 4. 匿名内部类 ```java package oop.demo10; public class Test &#123; public static void main(String[] args) &#123; //有名字初始化类 Apple apple = new Apple(); apple.eat(); //没有名字初始化类 new Apple().eat(); &#125; &#125; class Apple &#123; public void eat() &#123; System.out.println(&quot;1&quot;); &#125; &#125; 异常概念异常：在程序执行过程中，出现了非正常的情况，最终会导致JVM的非正常停止 在java等面向对象的编程语言中，异常本来就是一个类，产生异常就是创建一个异常对象并抛出了一个异常对象。java处理异常的方式是中断处理。 Throwable 五个关键字自定义异常使用java内置的异常类可以描述在编程时出现的大部分异常情况。除了这些异常，我们可以自定义异常 如何自定义异常 12345678910111213141516171819202122232425262728package exception.demo02;/*自定义异常1.创建自定义异常类2.在方法中通过Throw关键字抛出异常对象3.如果要在当前抛出异常的方法中处理异常，可以用try-catch语句捕获异常，并处理异常；否则就在方法的声明出通过throws关键字指明要抛出给方法调用者的异常4.在出现异常的方法的调用者中处理和捕获异常 *///1.创建自定义异常类,继承Exception类public class MyException extends Exception &#123; //传递数字，&gt;10就抛出异常 private int detail; public MyException( int a) &#123; this.detail = a; &#125; @Override public String toString() &#123;//异常的打印信息 return &quot;MyException&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021package exception.demo02;public class Test &#123; //可能会存在异常的方法 static void test (int a) throws MyException &#123; System.out.println(&quot;传递的参数为&quot;+a); if (a&gt;10) &#123; throw new MyException(a); &#125; System.out.println(&quot;OK&quot;); &#125; public static void main(String[] args) &#123; try &#123; test(11); &#125; catch (MyException e) &#123; System.out.println(&quot;MyException&quot;+e); &#125; &#125;&#125; 异常总结 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch 在多重catch块后面，可以加一个catch(Excption)来处理可能被遗漏的异常 对于不确定的代码，也可以加try-catch，来处理潜在的异常 尽量去处理异常，切忌只简单地调用printStackTrace()去打印输出 具体如何处理异常要根据不同的业务需求和异常类型去决定 尽量添加finally语句去释放已经占用的资源","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2021-04-28T21:57:24.000Z","updated":"2021-05-11T06:12:23.054Z","comments":true,"path":"2021/04/29/Markdown语法/","link":"","permalink":"http://example.com/2021/04/29/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。","text":"Markdown语法Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。 标题：#+空格+标题名称：一级标题 ##+空格+标题名称：二级标题 … 字体：粗体 **在字的两边加** 斜体 *在字的两边加* 删除线 ~~在字左右加~~ 引用： &gt;+空格就是引用 分割线： ---或*** 图片： !+[这里面写图片名称]+(这里面写图片地址) 超链接：B站 [这里网站名称]+(这里写网址) 列表 1+.+空格 -+空格 表格：| 表头 | 表头|| --- | --- || 内容 | 内容 | 代码：三个` esc下面的按键（英文状态下） 12345public class Hello&#123; public static void main (String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 代办事项-+空格+ [空格]-+空格+ [x] 事项1 事项2 数学公式$$y=2x^2+1​$$ $$E=mc^2$$ $$\\sum_{i=1}^n a_i=0$$ 快捷键window + e esc下面的按键（英文状态下）","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"Hexo博客的搭建部署","slug":"Hexo博客的搭建部署","date":"2021-04-19T16:21:24.000Z","updated":"2021-05-13T13:22:48.526Z","comments":true,"path":"2021/04/20/Hexo博客的搭建部署/","link":"","permalink":"http://example.com/2021/04/20/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/","excerpt":"Hexo博客搭建教程Hexo官方文档 搭建环境下载安装Git 到Git官网下载合适版本的Git，并安装 检测安装是否成功 1git --version//查看Git版本","text":"Hexo博客搭建教程Hexo官方文档 搭建环境下载安装Git 到Git官网下载合适版本的Git，并安装 检测安装是否成功 1git --version//查看Git版本 Git安装成功后可以用Git Bash来进行命令行操作 下载安装Note.js 到Note.js中文官网下载合适的版本，并安装 检测是否安装成功 12node -v//查看note版本npm -v//查看npm版本 搭建本地博客安装Hexo 打开Git Bash，输入下面的命令 1npm install -g hexo-cli 检测是否安装成功 1hexo -v 博客初始化 新建一个文件夹作为博客的目录，例如将博客目录设置为myblog 1hexo init myblog 初始化博客 12cd myblognpm install 博客本地效果 Git Bash执行下面的命令 12hexo -g//生成静态页面hexo server//本地预览 查看本地博客效果 将博客部署到Github创建个人Github仓库 注册一个Github账号，并登录 新建一个Github仓库，并命名为yourname.github.io。必须按此格式命名，这里yourname可以自定义，比如我的仓库名Linsip.github.io 配置SSH Git Bash输入下面的命令，生成密钥 12git config --global user.name &quot;你的github账户名字&quot;git config --global user.email &quot;你的github邮箱&quot; 检测输入的用户名与邮箱是否正确 12git config user.namegit config user.email 输入下面命令创建SSH密钥 1ssh-keygen -t rsa -C &quot;youremail&quot; 上传SSH密钥到Github 部署代码到Github上 找到并打开配置文件，修改其内容 Git Bash输入下面命令，安装hexo-deployer-git 1npm install hexo-deployer-git --save// 继续执行下面的命令 123hexo clean//hexo generate//hexo deploy// 打开网址http://yourname.github.io就可以看到你自己搭建的博客。这里的yourname就是你Github仓库的名字 设置个人域名购买域名待完善 Hexo博客常用命令新建博客目录1hexo init &lt;folder&gt; 新建文章123hexo new [layout] &lt;title&gt;//例如hexo n &quot;我的第一篇博客&quot; 生成静态页面1hexo generate 部署内容到网站1hexo deploy 启用本地预览1hexo server Hexo博客常见问题更换博客主题到Hexo官网找到自己喜欢的主题， 让后输入以下命令 1","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"玩机","slug":"玩机","permalink":"http://example.com/categories/%E7%8E%A9%E6%9C%BA/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"LG G7ThinQ","slug":"LG-G7ThinQ","permalink":"http://example.com/tags/LG-G7ThinQ/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Java, GUI","slug":"Java-GUI","permalink":"http://example.com/tags/Java-GUI/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}